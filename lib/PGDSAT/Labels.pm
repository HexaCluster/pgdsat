package PGDSAT::Labels;
#------------------------------------------------------------------------------
# Project  : PostgreSQL Database Security Assement Tool
# Name     : PGDSAT/Labels.pm
# Language : Perl
# Authors  : Gilles Darold
# Copyright: Copyright (c) 2024 HexaCluster Corp
# Function : Language module to import the securiy check description
#------------------------------------------------------------------------------
use vars qw($VERSION %AUDIT_LBL);
use strict;

$VERSION = '1.0';

%AUDIT_LBL = (
	'en_US' => {

		'1' => {
			'title' => 'Installation and Patches',
		},
		'1.1' => {
			'title' => 'Ensure packages are obtained from authorized repositories',
			'description' => 'Identify and inspect configured repositories to ensure they are all valid and authorized sources of packages.',
		},
		'1.1.1' => {
			'title' => 'PostgreSQL packages installed.',
			'description' => 'Inspect installed package to ensure they are all valid and authorized packages.',
			'manual' => 1,
		},
		'1.1.2' => {
			'title' => 'Ensure packages are obtained from PGDG',
			'description' => 'PostgreSQL packages not supported by the PostgreSQL community are generaly not recommended.',
		},
		'1.2' => {
			'title' => 'Ensure systemd Service Files Are Enabled',
			'description' => 'Check that the PostgreSQL systemd service is enabled. Enabling the systemd PostgreSQL service ensures that the database service is active when at system startup and reboot. This check is not done if Patroni is installed, in this case the start of PostgreSQL is handled by Patroni. (HexaCLuster)',
		},
		'1.3' => {
			'title' => 'Ensure Data Cluster Initialized Successfully',
			'description' => 'PostgreSQL enforces ownership and permissions of the data cluster such that the data cluster cannot be accessed by other UNIX user accounts and the data cluster cannot owned by root.',
		},
		'1.3.1' => {
			'title' => 'Check initialization of the PGDATA',
			'description' => 'The command initdb might have been run before starting PostgreSQL, verify that this is the case.',
		},
		'1.3.2' => {
			'title' => 'Check version in PGDATA',
			'description' => 'PostgreSQL maintain a file called PG_VERSION in the base directory, verify that .',
		},
		'1.3.3' => {
			'title' => 'Ensure Data Cluster have checksum enabled',
			'description' => 'When checksum are not enabled, silent data corruption can not be detected by PostgreSQL. Verify that they are enabled. (*)',
		},
		'1.3.4' => {
			'title' => 'Ensure WALs and temporary files are not on the same partition as the PGDATA',
			'description' => 'The PostgreSQL cluster is organized to carry out specific tasks in subdirectories. For the purposes of performance, reliability, and security some of these subdirectories should be relocated outside the data cluster. (*)',
		},
		'1.3.5' => {
			'title' => 'Ensure that the PGDATA partition is encrypted',
			'description' => 'PostgreSQL storage encryption can be performed at the file system level or the block level, for example using LUKS. This mechanism prevents unencrypted data from being read from the drives if the drives or the entire computer is stolen. This does not protect against attacks while the file system is mounted, because when mounted, the operating system provides an unencrypted view of the data. (*)',
			'manual' => 1,
		},
		'1.4' => {
		       'title' => 'Ensure PostgreSQL versions are up-to-date',
		       'descritption' => 'PostgreSQL minor upgrades contain only bugs and security fixes. There are no new features, new bugs and no compatibility problems with a minor upgrade, they are always fully binary compatible. You should always install minor releases as soon as they are published. For minor releases, the community considers not upgrading to be riskier than upgrading.',
	        },
		'1.5' => {
		       'title' => 'Ensure unused PostgreSQL extensions are removed',
		       'descritption' => 'PostgreSQL extensions are created in database, some may not be used anymore. This is a risk to keep unused extension installed in a database.',
			'manual' => 1,
	        },
		'1.6' => {
		       'title' => 'Ensure tablespace location is not inside the PGDATA',
		       'descritption' => 'Creating a tablespace in the data directory is useless and not recommended for performances reason and disk space use (*).',
	        },
#---------------------------
		'2' => {
			'title' => 'Directory and File Permissions',
		},
		'2.1' => {
			'title' => 'Ensure the file permissions mask is correct',
			'description' => 'The postgres system user should have a restrictive umask for file creation so that other UNIX users can not look at anything.',
		},
		'2.2' => {
			'title' => 'Check permissions of PGDATA',
			'description' => 'The data cluster Unix permissions must be 0700 (*).',
		},
		'2.3' => {
			'title' => 'List content of PGDATA to check unwanted files and symlinks',
			'description' => 'The content of the PGDATA must be generated by PostgreSQL itself except custom configuration files. (*).',
			'manual' => 1,
		},
		'2.4' => {
			'title' => 'Check permissions of pg_hba.conf',
			'description' => 'The pg_hba.conf UNIX permission must be 0640 or 0600, especially when it is stored outside the PGDATA (*).',
		},
		'2.5' => {
			'title' => 'Check permissions on Unix Socket',
			'description' => 'The default permissions are 0777, meaning anyone can connect. Reasonable alternatives are 0770 (only user and group, see also unix_socket_group) and 0700 (only user). (*).',
		},
#---------------------------
		'3' => {
			'title' => 'Logging And Auditing',
		},
		'3.1' => {
			'title' => 'PostgreSQL Logging',
			'description' => 'This section provides guidance with respect to PostgreSQL\'s logging behavior as it applies to security and auditing.',
		},
		'3.1.1' => {
			'title' => 'Logging Rationale',
			'description' => 'Having an audit trail is an important feature of any relational database system. You want enough detail to describe when an event of interest has started and stopped, what the event is/was, the event\'s cause, and what the event did/is doing to the system. Ideally, the logged information is in a format permitting further analysis giving us new perspectives and insight.',
		},
		'3.1.2' => {
			'title' => 'Ensure the log destinations are set correctly',
			'description' => 'If log_destination is not set, then any log messages generated by the core
PostgreSQL processes will be lost.',
		},
		'3.1.3' => {
			'title' => 'Ensure the logging collector is enabled',
			'description' => 'The logging collector approach is often more useful than logging to syslog, since some types of messages might not appear in syslog output. One common example is dynamic-linker failure message; another may be error messages produced by scripts such as archive_command.',
		},
		'3.1.4' => {
			'title' => 'Ensure the log file destination directory is set correctly',
			'description' => 'If log_directory is not set, it is interpreted as the absolute path \'/\' and PostgreSQL will attempt to write its logs there',
		},
		'3.1.5' => {
			'title' => 'Ensure the filename pattern for log files is set correctly',
			'description' => 'If log_filename is not set, then the value of log_directory is appended to an empty string and PostgreSQL will fail to start as it will try to write to a directory instead of a file.',
			'manual' => 1,
		},
		'3.1.6' => {
			'title' => 'Ensure the log file permissions are set correctly',
			'description' => 'Log files often contain sensitive data. Allowing unnecessary access to log files may inadvertently expose sensitive data to unauthorized personnel.',
		},
		'3.1.7' => {
			'title' => 'Ensure \'log_truncate_on_rotation\' is enabled',
			'description' => 'If this setting is disabled, pre-existing log files will be appended to if log_filename is configured in such a way that static or recurring names are generated.',
		},
		'3.1.8' => {
			'title' => 'Ensure the maximum log file lifetime is set correctly',
			'description' => 'Current best practices advise log rotation at least daily, but your organization\'s logging policy should dictate your rotation schedule.',
			'manual' => 1,
		},
		'3.1.9' => {
			'title' => 'Ensure the maximum log file size is set correctly',
			'description' => 'If this is set to zero, the size-triggered creation of new log files is disabled. This will prevent automatic log file rotation when files become too large, which could put log data at increased risk of loss (unless age-based rotation is configured).',
			'manual' => 1,
		},
		'3.1.10' => {
			'title' => 'Ensure the correct syslog facility is selected',
			'description' => 'If not set to the appropriate facility, the PostgreSQL log messages may be intermingled with other applications log messages, incorrectly routed, or potentially dropped (depending on your syslog configuration).',
			'manual' => 1,
		},
		'3.1.11' => {
			'title' => 'Ensure syslog messages are not suppressed',
			'description' => 'If disabled, messages sent to Syslog could be suppressed and not logged. While a message is emitted stating that a given message was repeated and suppressed, the timestamp associated with these suppressed messages is lost, potentially damaging the recreation of an incident timeline.',
		},
		'3.1.12' => {
			'title' => 'Ensure syslog messages are not lost due to size',
			'description' => 'Depending on the Syslog server in use, log messages exceeding 1024 bytes may be lost or, potentially, cause the Syslog server processes to abort.',
		},
		'3.1.13' => {
			'title' => 'Ensure the program name for PostgreSQL syslog messages is correct',
			'description' => 'If this is not set correctly, it may be difficult or impossible to distinguish PostgreSQL messages from other messages in Syslog logs.',
			'manual' => 1,
		},
		'3.1.14' => {
			'title' => 'Ensure the correct messages are written to the server log',
			'description' => 'If this is not set to the correct value, too many or too few messages may be written to the server log.',
		},
		'3.1.15' => {
			'title' => 'Ensure the correct SQL statements generating errors are recorded',
			'description' => 'If this is not set to the correct value, too many erring or too few erring SQL statements may be written to the server log.',
		},
		'3.1.16' => {
			'title' => 'Ensure \'debug_print_parse\' is disabled',
			'description' => 'Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.',
		},
		'3.1.17' => {
			'title' => 'Ensure \'debug_print_rewritten\' is disabled',
			'description' => 'Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.',
		},
		'3.1.18' => {
			'title' => 'Ensure \'debug_print_plan\' is disabled',
			'description' => 'Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.',
		},
		'3.1.19' => {
			'title' => 'Ensure \'debug_pretty_print\' is enabled',
			'description' => 'If this setting is disabled, the "compact" format is used instead, significantly reducing the readability of the DEBUG statement log messages.',
		},
		'3.1.20' => {
			'title' => 'Ensure \'log_connections\' is enabled',
			'description' => 'PostgreSQL does not maintain an internal record of attempted connections to the database for later auditing. It is only by enabling the logging of these attempts that one can determine if unexpected attempts are being made.',
		},
		'3.1.21' => {
			'title' => 'Ensure \'log_disconnections\' is enabled',
			'description' => 'PostgreSQL does not maintain the beginning or ending of a connection internally for later review. It is only by enabling the logging of these that one can examine connections for failed attempts, \'over long\' duration, or other anomalies.',
		},
		'3.1.22' => {
			'title' => 'Ensure \'log_error_verbosity\' is set correctly',
			'description' => 'If this is not set to the correct value, too many details or too few details may be logged.',
		},
		'3.1.23' => {
			'title' => 'Ensure \'log_hostname\' is set correctly',
			'description' => 'Depending on your hostname resolution setup, enabling this setting might impose a non-negligible performance penalty. Additionally, the IP addresses that are logged can be resolved to their DNS names when reviewing the logs (unless dynamic hostnames are being used as part of your DHCP setup).',
		},
		'3.1.24' => {
			'title' => 'Ensure \'log_line_prefix\' is set correctly',
			'description' => 'Properly setting log_line_prefix allows for adding additional information to each log entry (such as the user, or the database). Said information may then be of use in auditing or security reviews. The prefix should at least include \'%m [%p]: db=%d,user=%u,app=%a,client=%h \' (for logging to stderr) and for syslog logging, the prefix should include \'user=%u,db=%d,app=%a,client=%h \'.',
		},
		'3.1.25' => {
			'title' => 'Ensure \'log_statement\' is set correctly',
			'description' => 'Setting log_statement to align with your organization\'s security and logging policies facilitates later auditing and review of database activities.',
		},
		'3.1.26' => {
			'title' => 'Ensure \'log_timezone\' is set correctly',
			'description' => 'Log entry timestamps should be configured for an appropriate time zone as defined by your organization\'s logging policy to ensure a lack of confusion around when a logged event occurred.  Note that this setting affects only the timestamps present in the logs.',
		},
		'3.1.27' => {
			'title' => 'Ensure that log_directory is outside the PGDATA',
			'description' => 'Best practice is to not write PostgreSQL logs into the PGDATA for performances reason and disk space use. (*)',
		},
		'3.2' => {
			'title' => 'Ensure the PostgreSQL Audit Extension (pgAudit) is enabled',
			'description' => 'The PostgreSQL Audit Extension (pgAudit) provides detailed session and/or object audit logging via the standard PostgreSQL logging facility. The goal of pgAudit is to provide PostgreSQL users with the capability to produce audit logs often required to comply with government, financial, or ISO certifications.',
		},
#---------------------------
		'4' => {
			'title' => 'User Access and Authorization',
			'description' => 'These authorizations must be structured to block unauthorized use and/or corruption of vital data and services by setting restrictions on user capabilities.',
		},
		'4.1' => {
			'title' => 'Ensure sudo is configured correctly',
			'description' => 'Without sudo, there would be no capabilities to strictly control access to the superuser account nor to securely and authoritatively audit its use.',
			'manual' => 1,
		},
		'4.2' => {
			'title' => 'Ensure excessive administrative privileges are revoked',
			'description' => 'By not restricting global administrative commands to superusers only, regular users granted excessive privileges may execute administrative commands with unintended and undesirable results.',
		},
		'4.3' => {
			'title' => 'Ensure excessive function privileges are revoked',
			'description' => 'Functions in PostgreSQL can be created with the SECURITY DEFINER option. When SECURITY DEFINER functions are executed by a user, said function is run with the privileges of the user who created it, not the user who is running it. List of the functions with SECURITY DEFINER option not associated to an extension, per database.',
			'manual' => 1,
		},
		'4.4' => {
			'title' => 'Ensure excessive DML privileges are revoked',
			'description' => 'Excessive DML grants can lead to unprivileged users changing or deleting information without proper authorization.',
			'manual' => 1,
		},
		'4.5' => {
			'title' => 'Ensure Row Level Security (RLS) is configured correctly',
			'description' => 'If RLS policies and privileges are not configured correctly, users could perform actions on tables that they are not authorized to perform, such as inserting, updating, or deleting rows. List tables with RLS enabled.',
			'manual' => 1,
		},
		'4.6' => {
			'title' => 'Ensure the set_user extension is installed',
			'description' => 'Even when reducing and limiting the access to the superuser role, it is still difficult to determine who accessed the superuser role and what actions were taken using that role. As such, it is ideal to prevent anyone from logging in as the superuser and forcing them to escalate their role. The set_user extension allows for this setup.',
			'manual' => 1,
		},
		'4.7' => {
			'title' => 'Make use of predefined roles',
			'description' => 'In keeping with the principle of least privilege, judicious use of the PostgreSQL predefined roles can greatly limit the access to privileged, or superuser, access.',
			'manual' => 1,
		},
		'4.8' => {
			'title' => 'Ensuse the public schema is protected',
			'description' => 'Privileges on the PostgreSQL default public schema must be restricted to some users, grant to public users must be removed or the schema dropped.',
		},
#---------------------------
		'5' => {
			'title' => 'Connection and Login',
			'description' => 'The restrictions on client/user connections to the PostgreSQL database blocks unauthorized access to data and services by setting access rules. These security measures help to ensure that successful logins cannot be easily made through brute-force password attacks, replaying the password hash, or intuited by clever social engineering exploits.',
		},
		'5.1' => {
			'title' => 'Ensure login via "local" UNIX Domain Socket is configured correctly',
			'description' => 'A remote host login, via SSH, is arguably the most secure means of remotely accessing and administering the PostgreSQL server. Once connected to the PostgreSQL server, using the psql client, via UNIX DOMAIN SOCKETS, while using the peer authentication method is the most secure mechanism available for local database connections.',
		},
		'5.2' => {
			'title' => 'Ensure login via "host" TCP/IP Socket is configured correctly',
			'description' => 'A large number of authentication methods are available for hosts connecting using TCP/IP sockets. Methods trust, password, and ident are not to be used for remote logins. Method md5 used to be the most popular and can be used in both encrypted and unencrypted sessions, however, it is vulnerable to packet replay attacks. It is recommended that scram-sha-256 be used instead of md5. Use of the gss, sspi, pam, ldap, radius, and cert methods are dependent upon the availability of external authenticating processes/services and thus are not covered here.',
		},
		'5.3' => {
			'title' => 'Ensure Password Complexity is configured',
			'description' => 'Having strong password management for your locally-authenticated PostgreSQL accounts will protect against attackers\' brute force techniques. This is important especially if external authentication is not possible to implement due to application requirements or restrictions.',
		},
		'5.4' => {
			'title' => 'Ensure authentication timeout and delay are well configured',
			'description' => 'Authentication timeout is the maximum amount of time allowed to complete client authentication. If a would-be client has not completed the authentication protocol in this much time, the server closes the connection. This prevents hung clients from occupying a connection indefinitely. Authentication delay causes the server to pause briefly before reporting authentication failure, to make brute-force attacks on database passwords more difficult. (*)',
		},
		'5.5' => {
			'title' => 'Ensure SSL is used for client connection',
			'description' => 'All remote client connection should be encrypted and non encrypted connexion  should be reject to not permit data sniffing on the network. (*)',
		},
		'5.6' => {
			'title' => 'Ensure authorized Ip addresses ranges are not too large',
			'description' => 'Allowing a too large range of Ip addresses to connect to PostgreSQL cluster multiply the risks unnecessarily. (*)',
		},
		'5.7' => {
			'title' => 'Ensure specific database and users are used',
			'description' => 'The keyword "all" in the database and user part of the pg_hba.conf rules can allow any user to connect to any database, it is recommended to restrict the connection to specific user and database. (*)',
		},
		'5.8' => {
			'title' => 'Ensure superusers are not allowed to connect remotely',
			'description' => 'Allowing a PostgreSQL superuser to connect to a database from a remote host is dangerous, best is to only allow the superuser(s) to connect locally with a peer authentication. If some advanced privileges are required, best is to use the PostgreSQL predefined roles. (*)',
		},
		'5.9' => {
			'title' => 'Ensure that \'password_encryption\' is correctly set',
			'description' => 'PostgreSQL allow to set password encryption, default is now \'scram-sha-256\' but it can be set to \'md5\' which is insecure. (*)',
		},
#---------------------------
		'6' => {
			'title' => 'PostgreSQL Settings',
		},
		'6.1' => {
			'title' => 'Understanding attack vectors and runtime parameters',
		},
		'6.2' => {
			'title' => 'Ensure \'backend\' runtime parameters are configured correctly',
			'description' => 'A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis. All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.',
		},
		'6.3' => {
			'title' => 'Ensure \'Postmaster\' runtime parameters are configured correctly',
			'description' => 'The postmaster process is the supervisory process that assigns a backend process to an incoming client connection. The postmaster manages key runtime parameters that are either shared by all backend connections or needed by the postmaster process itself to run. The following parameters can only be set at server start by the owner of the PostgreSQL server process and cluster, typically the UNIX user account postgres.  Therefore, all exploits require the successful compromise of either that UNIX account or the postgres superuser account itself.',
			'manual' => 1,
		},
		'6.4' => {
			'title' => 'Ensure \'SIGHUP\' runtime parameters are configured correctly',
			'description' => 'In order to define server behavior and optimize server performance, the server\'s superuser has the privilege of setting these parameters which are found in the configuration files postgresql.conf and pg_hba.conf. Alternatively, those parameters found in postgresql.conf can also be changed using a server login session and executing the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf. All changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.',
			'manual' => 1,
		},
		'6.5' => {
			'title' => 'Ensure \'Superuser\' runtime parameters are configured correctly',
			'description' => 'In order to improve and optimize server performance, the server\'s superuser has the privilege of setting these parameters which are found in the configuration file postgresql.conf. Alternatively, they can be changed in a PostgreSQL login session via the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf. All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files. A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.',
			'manual' => 1,
		},
		'6.6' => {
			'title' => 'Ensure \'User\' runtime parameters are configured correctly',
			'description' => 'These PostgreSQL runtime parameters are managed at the user account (ROLE) level. In order to improve performance and optimize features, a ROLE has the privilege of setting numerous parameters in a transaction, session, or entity attribute. Any ROLE can alter any of these parameters. A denial of service is possible by the over-allocating of limited resources, such as RAM.  Changing VACUUM parameters can force a server shutdown which is standard procedure preventing data corruption from transaction ID wraparound. Data can be corrupted by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Logging can be altered and obfuscated to inhibit root cause analysis.',
			'manual' => 1,
		},
		'6.7' => {
			'title' => 'Ensure FIPS 140-2 OpenSSL cryptography is used',
			'description' => 'Install, configure, and use OpenSSL on a platform that has a NIST certified FIPS 140-2 installation of OpenSSL. This provides PostgreSQL instances the ability to generate and validate cryptographic hashes to protect unclassified information requiring confidentiality and cryptographic protection, in accordance with the data owner\'s requirements.',
		},
		'6.8' => {
			'title' => 'Ensure TLS is enabled and configured correctly',
			'description' => 'If TLS is not enabled and configured correctly, this increases the risk of data being compromised in transit. A self-signed certificate can be used for testing, but a certificate signed by a certificate authority (CA) (either one of the global CAs or a local one) should be used in production so that clients can verify the server\'s identity. If all the database clients are local to the organization, using a local CA is recommended. To ultimately enable and enforce TLS authentication for the server, appropriate "hostssl" records must be added to the pg_hba.conf file.',
		},
		'6.9' => {
			'title' => 'Ensure a cryptographic extension is installed',
			'description' => 'PostgreSQL instances handling data that requires "data at rest" protections must employ cryptographic mechanisms to prevent unauthorized disclosure and modification of the information at rest. These cryptographic mechanisms may be native to PostgreSQL or implemented via additional software or operating system/file system settings, as appropriate to the situation.',
		},
		'7' => {
			'title' => 'Replication',
		},
		'7.1' => {
			'title' => 'Ensure a replication-only user is created and used for streaming replication',
			'description' => 'As it is not necessary to be a superuser to initiate a replication connection, it is proper to create an account specifically for replication. This allows further "locking down" the uses of the superuser account and follows the general principle of using the least privileges necessary.',
		},
		'7.2' => {
			'title' => 'Ensure logging of replication commands is configured',
			'description' => 'A successful replication connection allows for a complete copy of the data stored within the data cluster to be offloaded to another, potentially insecure, host. As such, it is advisable to log all replication commands that are executed in your database cluster to ensure the data is not off-loaded to an unexpected/undesired location.',
		},
		'7.3' => {
			'title' => 'Ensure base backups are configured and functional',
			'description' => 'A \'base backup\' is a copy of the PRIMARY host\'s data cluster (PGDATA) and is used to create STANDBY hosts and for Point In Time Recovery (PITR) mechanisms. Base backups should be copied across networks in a secure manner using an encrypted transport mechanism. The PostgreSQL CLI pg_basebackup can be used, however, TLS encryption should be enabled on the server as per section 6.8 of this benchmark.',
		},
		'7.4' => {
			'title' => 'Ensure WAL archiving is configured and functional',
			'description' => 'Write Ahead Log (WAL) Archiving, or Log Shipping, is the process of sending transaction log files from the PRIMARY host either to one or more STANDBY hosts or to be archived on a remote storage device for later use, e.g. PITR. There are several utilities that can copy WALs including, but not limited to, cp, scp, sftp, and rynsc. Basically, the server follows a set of runtime parameters which define when the WAL should be copied using one of the aforementioned utilities.',
		},
		'7.5' => {
			'title' => 'Ensure streaming replication parameters are configured correctly',
			'description' => 'Streaming replication from a PRIMARY host transmits DDL, DML, passwords, and other potentially sensitive activities and data. These connections should be protected with Secure Sockets Layer (SSL). Verify on STANDBY that primary_conninfo contains \'sslmode=require sslcompression=1\'',
		},
		'8' => {
			'title' => 'Special Configuration Considerations',
			'description' => 'The recommendations proposed here try to address some of the less common use cases which may warrant additional configuration guidance/consideration.',
		},
		'8.1' => {
			'title' => 'Ensure PostgreSQL subdirectory locations are outside the data cluster',
			'description' => 'This report is part of chapter <a href="#1.3">"1.3 Ensure Data Cluster Initialized Successfully"</a>.',
		},
		'8.2' => {
			'title' => 'Ensure the backup and restore tool, \'pgBackRest\', is installed and configured',
			'description' => 'The native PostgreSQL backup facility pg_dump provides adequate logical backup operations but does not provide for Point In Time Recovery (PITR). The PostgreSQL facility pg_basebackup performs a physical backup of the database files and does provide for PITR, but it is constrained by single threading. Both of these methodologies are standard in the PostgreSQL ecosystem and appropriate for particular backup/recovery needs. pgBackRest offers another option with much more robust features and flexibility.',
		},
		'8.3' => {
			'title' => 'Ensure miscellaneous configuration settings are correct',
			'description' => 'This recommendation covers non-regular, special files, and dynamic libraries. PostgreSQL permits local logins via the UNIX DOMAIN SOCKET and, for the most part, anyone with a legitimate Unix login account can make the attempt. Limiting PostgreSQL login attempts can be made by relocating the UNIX DOMAIN SOCKET to a subdirectory with restricted permissions. The creation and implementation of user-defined dynamic libraries is an extraordinary powerful capability. In the hands of an experienced DBA/programmer, it can significantly enhance the power and flexibility of the RDBMS; but new and unexpected behavior can also be assigned to the RDBMS, resulting in a very dangerous environment in what should otherwise be trusted.',
			'manual' => 1,
		},
	},

#------------------------------------------------------------------------------------------------------
	'fr_FR' => {
#------------------------------------------------------------------------------------------------------

		'1' => {
			'title' => 'Installation et correctifs',
		},
		'1.1' => {
			'title' => 'Vérifier que les packages sont obtenus à partir de dépots autorisés',
			'description' => 'Identifiez et inspectez les dépots configurés pour vous assurer qu\'ils constituent tous des sources de packages valides et autorisées.',
		},
		'1.1.1' => {
			'title' => 'Paquets PostgreSQL installés.',
			'description' => 'Inspectez les packages installés pour vous assurer qu\'ils sont tous des packages valides et autorisés.',
			'manuel' => 1,
		},
		'1.1.2' => {
			'title' => 'Vérifier que les packages sont obtenus auprès de PGDG',
			'description' => 'Les packages PostgreSQL non pris en charge par la communauté PostgreSQL ne sont généralement pas recommandés.',
		},
		'1.2' => {
			'title' => 'Vérifier que les fichiers du service systemd sont activés',
			'description' => 'Vérifiez que le service systemd PostgreSQL est activé. L\'activation du service systemd PostgreSQL garantit que le service de base de données est actif au démarrage et au redémarrage du système. Cette vérification n\'est pas effectuée si Patroni est installé, dans ce cas le démarrage de PostgreSQL est géré par Patroni. (HexaCLustre)',
		},
		'1.3' => {
			'title' => 'Vérifier l\'initialisation réussie du cluster de données',
			'description' => 'PostgreSQL applique la propriété et les autorisations du cluster de données de telle sorte que le cluster de données ne soit pas accessible par d\'autres comptes utilisateurs UNIX et que le cluster de données ne puisse pas appartenir à root.',
		},
		'1.3.1' => {
			'title' => 'Vérifier l\'initialisation du PGDATA',
			'description' => 'La commande initdb a peut-être été exécutée avant de démarrer PostgreSQL, vérifiez que c\'est le cas.',
		},
		'1.3.2' => {
			'title' => 'Vérifier la version dans PGDATA',
			'description' => 'PostgreSQL maintient un fichier appelé PG_VERSION dans le répertoire de base, vérifiez que .',
		},
		'1.3.3' => {
			'title' => 'Verifier que les checksum du cluster de données est activée',
			'description' => 'Lorsque les checksum ne sont pas activées, la corruption silencieuse des données ne peut pas être détectée par PostgreSQL. Vérifiez qu\'ils sont activés. (*)',
		},
		'1.3.4' => {
			'title' => 'Vérifier que les WAL et les fichiers temporaires ne se trouvent pas sur la même partition que PGDATA',
			'description' => 'Le cluster PostgreSQL est organisé pour effectuer des tâches spécifiques dans des sous-répertoires. Pour des raisons de performances, de fiabilité et de sécurité, certains de ces sous-répertoires doivent être déplacés en dehors du cluster de données. (*)',
		},
		'1.3.5' => {
			'title' => 'Vérifier que la partition PGDATA est chiffrée',
			'description' => 'Le chiffrement du stockage PostgreSQL peut être effectué au niveau du système de fichiers ou au niveau du bloc, par exemple en utilisant LUKS. Ce mécanisme empêche la lecture de données non cryptées sur les disques en cas de vol des disques ou de l\'intégralité de l\'ordinateur. Cela ne protège pas contre les attaques pendant le montage du système de fichiers, car une fois monté, le système d\'exploitation fournit une vue non chiffrée des données. (*)',
			'manuel' => 1,
		},
		'1.4' => {
		       'title' => 'Vérifier que les versions de PostgreSQL sont à jour',
		       'descritption' => 'Les mises à jour mineures de PostgreSQL contiennent uniquement des correctifs de bugs et de sécurité. Il n\'y a pas de nouvelles fonctionnalités, de nouveaux bugs et aucun problème de compatibilité avec une mise à jour mineure, ils sont toujours entièrement binaires compatibles. Vous devez toujours installer les versions mineures dès qu\'elles sont publiées. Pour les versions mineures, la communauté considère que ne pas mettre à niveau est plus risqué que la mise à niveau.',
	        },
		'1.5' => {
		       'title' => 'Vérifier que les extensions PostgreSQL inutilisées sont supprimées',
		       'descritption' => 'Les extensions PostgreSQL sont créées dans la base de données, certaines ne peuvent plus être utilisées. Il est risqué de conserver les extensions inutilisées installées dans une base de données.',
			'manuel' => 1,
	        },
		'1.6' => {
		       'title' => 'Vérifier que la destination des tablespaces n\'est pas dans le PGDATA',
		       'descritption' => 'Créer un tablespace dans le répertoire des données est inutile est absoluement pas recommendé pour des raisons de performances et d\'utilisation d\'espace disque (*).',
	        },
#-------------------------------
		'2' => {
			'title' => 'Autorisations de répertoire et de fichier',
		},
		'2.1' => {
			'title' => 'Vérifier que le masque d\'autorisations du fichier est correct',
			'description' => 'L\'utilisateur du système postgres doit avoir un umask restrictif pour la création de fichiers afin que les autres utilisateurs UNIX ne puissent rien voir.',
		},
		'2.2' => {
			'title' => 'Vérifier les autorisations de PGDATA',
			'description' => 'Les autorisations Unix du cluster de données doivent être 0700 (*).',
		},
		'2.3' => {
			'title' => 'Liste du contenu de PGDATA pour vérifier les fichiers et liens symboliques indésirables',
			'description' => 'Le contenu du PGDATA doit être généré par PostgreSQL lui-même, à l\'exception des fichiers de configuration personnalisés. (*).',
			'manuel' => 1,
		},
		'2.4' => {
			'title' => 'Vérifier les autorisations de pg_hba.conf',
			'description' => 'La permission UNIX pg_hba.conf doit être 0640 ou 0600, surtout lorsqu\'elle est stockée en dehors du PGDATA (*).',
		},
		'2.5' => {
			'title' => 'Vérifier les autorisations de la socket Unix',
			'description' => 'Les permissions par défaut sont 0777, ce qui veut dire que tout le monde peut se connecter. Une alternative raisonnable est 0770 (seulement l\'utilisateur et le groupe Unix, voir aussi unix_socket_group) at 0700 (l\'utilisateur seulement). (*).',
		},
#-------------------------------
		'3' => {
			'title' => 'Journalisation et audit',
		},
		'3.1' => {
			'title' => 'Journalisation PostgreSQL',
			'description' => 'Cette section fournit des conseils concernant le comportement de journalisation de PostgreSQL tel qu\'il s\'applique à la sécurité et à l\'audit.',
		},
		'3.1.1' => {
			'title' => 'Raison d\'être de la journalisation',
			'description' => 'Avoir une piste d\'audit est une caractéristique importante de tout système de base de données relationnelle. Vous voulez suffisamment de détails pour décrire quand un événement qui vous intéresse a commencé et s\'est arrêté, ce qu\'est l\'événement, sa cause et ce que l\'événement a fait au système. Idéalement, les informations enregistrées sont dans un format permettant une analyse plus approfondie nous donnant de nouvelles perspectives et informations.',
		},
		'3.1.2' => {
			'title' => 'Vérifier que les destinations des fichiers de log sont correctement définies',
			'description' => 'Si log_destination n\'est pas défini, alors tous les messages de journal générés par le noyau Les processus PostgreSQL seront perdus.',
		},
		'3.1.3' => {
			'title' => 'Vérifier que le collecteur de journaux est activé',
			'description' => 'L\'utilisation du collecteur de logs est souvent plus utile que la journalisation sur Syslog, car certains types de messages peuvent ne pas apparaître dans la sortie Syslog. Un exemple courant est le message d\'échec de l\'éditeur de liens dynamiques ; un autre peut être des messages d\'erreur produits par des scripts tels que archive_command.',
		},
		'3.1.4' => {
			'title' => 'Vérifier que le répertoire de destination des journaux est correctement défini',
			'description' => 'Si log_directory n\'est pas défini, il est interprété comme le chemin absolu \'/\' et PostgreSQL tentera d\'y écrire ses journaux',
		},
		'3.1.5' => {
			'title' => 'Vérifier que le modèle de nom de fichier pour les journaux est correctement défini',
			'description' => 'Si log_filename n\'est pas défini, alors la valeur de log_directory est ajoutée à une chaîne vide et PostgreSQL ne parviendra pas à démarrer car il tentera d\'écrire dans un répertoire au lieu d\'un fichier.',
			'manuel' => 1,
		},
		'3.1.6' => {
			'title' => 'Vérifier que les autorisations du fichier journal sont correctement définies',
			'description' => 'Les fichiers journaux contiennent souvent des données sensibles. Autoriser un accès inutile aux fichiers journaux peut exposer par inadvertance des données sensibles à du personnel non autorisé.',
		},
		'3.1.7' => {
			'title' => 'Vérifier que \'log_truncate_on_rotation\' est activé',
			'description' => 'Si ce paramètre est désactivé, les fichiers journaux préexistants seront ajoutés si log_filename est configuré de telle manière que des noms statiques ou récurrents soient générés.',
		},
		'3.1.8' => {
			'title' => 'Vérifier que la durée de vie maximale du fichier journal est correctement définie',
			'description' => 'Les meilleures pratiques actuelles conseillent une rotation des journaux au moins quotidiennement, mais la politique de journalisation de votre organisation doit dicter votre calendrier de rotation.',
			'manuel' => 1,
		},
		'3.1.9' => {
			'title' => 'Vérifier que la taille maximale du fichier journal est correctement définie',
			'description' => 'Si cette valeur est définie sur zéro, la création de nouveaux fichiers journaux déclenchée par la taille est désactivée. Cela empêchera la rotation automatique des fichiers journaux lorsque les fichiers deviennent trop volumineux, ce qui pourrait exposer les données des journaux à un risque accru de perte (à moins que la rotation basée sur l\'âge ne soit configurée).',
			'manuel' => 1,
		},
		'3.1.10' => {
			'title' => 'Vérifier que la bonne fonction Syslog est sélectionnée',
			'description' => 'S\'ils ne sont pas définis sur la fonction appropriée, les messages du journal PostgreSQL peuvent être mélangés avec les messages du journal d\'autres applications, mal acheminés ou potentiellement supprimés (en fonction de votre configuration syslog).',
			'manuel' => 1,
		},
		'3.1.11' => {
			'title' => 'Vérifier que les messages Syslog ne sont pas supprimés',
			'description' => 'Si désactivé, les messages envoyés à Syslog pourraient être supprimés et non enregistrés. Lorsqu\'un message est émis indiquant qu\'un message donné a été répété et supprimé, l\'horodatage associé à ces messages supprimés est perdu, ce qui peut potentiellement endommager la recréation d\'une chronologie d\'incident.',
		},
		'3.1.12' => {
			'title' => 'Vérifier que les messages Syslog ne sont pas perdus en raison de leur taille',
			'description' => 'En fonction du serveur Syslog utilisé, les messages de journal dépassant 1024 octets peuvent être perdus ou, potentiellement, provoquer l\'abandon des processus du serveur Syslog.',
		},
		'3.1.13' => {
			'title' => 'Vérifier que le nom du programme pour les messages syslog PostgreSQL est correct',
			'description' => 'Si ceci n\'est pas défini correctement, il peut être difficile, voire impossible, de distinguer les messages PostgreSQL des autres messages dans les journaux Syslog.',
			'manuel' => 1,
		},
		'3.1.14' => {
			'title' => 'Vérifier que les messages corrects sont écrits dans le journal du serveur',
			'description' => 'Si la valeur n\'est pas correcte, trop ou pas assez de messages peuvent être écrits dans le journal du serveur.',
		},
		'3.1.15' => {
			'title' => 'Vérifier que les instructions SQL correctes générant des erreurs sont enregistrées',
			'description' => 'Si la valeur n\'est pas correcte, trop ou pas assez d\'instructions SQL erronées peuvent être écrites dans le journal du serveur.',
		},
		'3.1.16' => {
			'title' => 'Vérifier que \'debug_print_parse\' est désactivé',
			'description' => 'L\'activation de l\'une des variables d\'impression DEBUG peut entraîner la journalisation d\'informations sensibles qui seraient autrement omises en fonction de la configuration des autres paramètres de journalisation.',
		},
		'3.1.17' => {
			'title' => 'Vérifier que \'debug_print_rewriting\' est désactivé',
			'description' => 'L\'activation de l\'une des variables d\'impression DEBUG peut entraîner la journalisation d\'informations sensibles qui seraient autrement omises en fonction de la configuration des autres paramètres de journalisation.',
		},
		'3.1.18' => {
			'title' => 'Vérifier que \'debug_print_plan\' est désactivé',
			'description' => 'L\'activation de l\'une des variables d\'impression DEBUG peut entraîner la journalisation d\'informations sensibles qui seraient autrement omises en fonction de la configuration des autres paramètres de journalisation.',
		},
		'3.1.19' => {
			'title' => 'Vérifier que \'debug_pretty_print\' est activé',
			'description' => 'Si ce paramètre est désactivé, le format "compact" est utilisé à la place, réduisant considérablement la lisibilité des messages du journal de l\'instruction DEBUG.',
		},
		'3.1.20' => {
			'title' => 'Vérifier que \'log_connections\' est activé',
			'description' => 'PostgreSQL ne conserve pas d\'enregistrement interne des tentatives de connexion à la base de données pour un audit ultérieur. Ce n\'est qu\'en activant la journalisation de ces tentatives que l\'on peut déterminer si des tentatives inattendues sont effectuées.',
		},
		'3.1.21' => {
			'title' => 'Vérifier que \'log_disconnections\' est activé',
			'description' => 'PostgreSQL ne conserve pas le début ou la fin d\'une connexion en interne pour une révision ultérieure. Ce n\'est qu\'en activant la journalisation de ces connexions que l\'on peut examiner les connexions à la recherche de tentatives infructueuses, de durées « de longue durée » ou d\'autres anomalies.',
		},
		'3.1.22' => {
			'title' => 'Vérifier que \'log_error_verbosity\' est correctement défini',
			'description' => 'Si la valeur n\'est pas correcte, trop ou pas assez de détails peuvent être enregistrés.',
		},
		'3.1.23' => {
			'title' => 'Vérifier que \'log_hostname\' est correctement défini',
			'description' => 'En fonction de la configuration de votre résolution de nom d\'hôte, l\'activation de ce paramètre peut imposer une pénalité de performances non négligeable. De plus, les adresses IP enregistrées peuvent être résolues en leurs noms DNS lors de l\'examen des journaux (sauf si des noms d\'hôte dynamiques sont utilisés dans le cadre de votre configuration DHCP).',
		},
		'3.1.24' => {
			'title' => 'Vérifier que \'log_line_prefix\' est correctement défini',
			'description' => 'Un réglage correct de log_line_prefix permet d\'ajouter des informations supplémentaires à chaque entrée de journal (telle que l\'utilisateur ou la base de données). Ces informations peuvent alors être utiles dans le cadre d’audits ou d’examens de sécurité. Le préfixe doit au moins inclure \'%m [%p] : db=%d,user=%u,app=%a,client=%h \' (pour la journalisation sur stderr) et pour la journalisation syslog, le préfixe doit inclure \'user=%u,db=%d,app=%a,client=%h \'.',
		},
		'3.1.25' => {
			'title' => 'Vérifier que \'log_statement\' est correctement défini',
			'description' => 'Configurer log_statement pour qu\'il s\'aligne sur les politiques de sécurité et de journalisation de votre organisation facilite l\'audit et l\'examen ultérieurs des activités de la base de données.',
		},
		'3.1.26' => {
			'title' => 'Vérifier que \'log_timezone\' est correctement défini',
			'description' => 'Les horodatages des entrées de journal doivent être configurés pour un fuseau horaire approprié tel que défini par la politique de journalisation de votre organisation afin de garantir l\'absence de confusion quant au moment où un événement enregistré s\'est produit. Notez que ce paramètre affecte uniquement les horodatages présents dans les journaux.',
		},
		'3.1.27' => {
			'title' => 'Vérifier que log_directory est en dehors de PGDATA',
			'description' => 'La meilleure pratique consiste à ne pas écrire de journaux PostgreSQL dans PGDATA pour des raisons de performances et d\'utilisation de l\'espace disque. (*)',
		},
		'3.2' => {
			'title' => 'Vérifier que l\'extension d\'audit PostgreSQL (pgAudit) est activée',
			'description' => 'L\'extension d\'audit PostgreSQL (pgAudit) fournit une journalisation détaillée de l\'audit de session et/ou d\'objet via la fonction de journalisation standard de PostgreSQL. L\'objectif de pgAudit est de fournir aux utilisateurs de PostgreSQL la capacité de produire des journaux d\'audit souvent requis pour se conformer aux certifications gouvernementales, financières ou ISO.',
		},
#-------------------------------
		'4' => {
			'title' => 'Accès utilisateur et autorisation',
			'description' => 'Ces autorisations doivent être structurées pour bloquer l\'utilisation non autorisée et/ou la corruption de données et de services vitaux en définissant des restrictions sur les capacités des utilisateurs.',
		},
		'4.1' => {
			'title' => 'Vérifier que sudo est correctement configuré',
			'description' => 'Sans sudo, il n\'y aurait aucune possibilité de contrôler strictement l\'accès au compte superutilisateur ni d\'auditer son utilisation de manière sécurisée et faisant autorité.',
			'manuel' => 1,
		},
		'4.2' => {
			'title' => 'Verifier que les privilèges administratifs excessifs soient révoqués',
			'description' => 'En ne limitant pas les commandes d\'administration globales aux superutilisateurs uniquement, les utilisateurs réguliers bénéficiant de privilèges excessifs peuvent exécuter des commandes d\'administration avec des résultats involontaires et indésirables.',
		},
		'4.3' => {
			'title' => 'Verifier que les privilèges de fonction excessifs soient révoqués',
			'description' => 'Des fonctions dans PostgreSQL peuvent être créées avec l\'option SECURITY DEFINER. Lorsque les fonctions SECURITY DEFINER sont exécutées par un utilisateur, ladite fonction est exécutée avec les privilèges de l\'utilisateur qui l\'a créée, et non de celui qui l\'exécute. Liste des fonctions avec option SECURITY DEFINER non associées à une extension, par base de données.',
			'manuel' => 1,
		},
		'4.4' => {
			'title' => 'Vérifier que les privilèges DML excessifs sont révoqués',
			'description' => 'Des autorisations DML excessives peuvent amener des utilisateurs non privilégiés à modifier ou à supprimer des informations sans autorisation appropriée.',
			'manuel' => 1,
		},
		'4.5' => {
			'title' => 'Vérifier que la sécurité au niveau des lignes (RLS) est correctement configurée',
			'description' => 'Si les politiques et privilèges RLS ne sont pas configurés correctement, les utilisateurs peuvent effectuer des actions sur les tables qu\'ils ne sont pas autorisés à effectuer, telles que l\'insertion, la mise à jour ou la suppression de lignes. Liste les tables avec RLS activé.',
			'manuel' => 1,
		},
		'4.6' => {
			'title' => 'Vérifier que l\'extension set_user est installée',
			'description' => 'Même en réduisant et en limitant l\'accès au rôle de superutilisateur, il reste difficile de déterminer qui a accédé au rôle de superutilisateur et quelles actions ont été entreprises en utilisant ce rôle. En tant que tel, il est idéal d’empêcher quiconque de se connecter en tant que superutilisateur et de le forcer à élever son rôle. L\'extension set_user permet cette configuration.',
			'manuel' => 1,
		},
		'4.7' => {
			'title' => 'Utiliser des rôles prédéfinis',
			'description' => 'Conformément au principe du moindre privilège, une utilisation judicieuse des rôles prédéfinis de PostgreSQL peut limiter considérablement l\'accès aux accès privilégiés ou superutilisateur.',
			'manuel' => 1,
		},
		'4.8' => {
			'title' => 'Vérifier que le schéma public ne peut pas être utilsé',
			'description' => 'Les privilèges sur le schéma public créé par PostgreSQL par défault doivent être restreints à certains utilisateurs ou supprimé.',
		},
#-------------------------------
		'5' => {
			'title' => 'Connexion et connexion',
			'description' => 'Les restrictions sur les connexions client/utilisateur à la base de données PostgreSQL bloquent l\'accès non autorisé aux données et services en définissant des règles d\'accès. Ces mesures de sécurité contribuent à garantir que les connexions réussies ne peuvent pas être facilement réalisées par le biais d\'attaques de mot de passe par force brute, par la relecture du hachage du mot de passe ou par des exploits d\'ingénierie sociale intelligents.',
		},
		'5.1' => {
			'title' => 'Vérifier que la connexion via le socket de domaine UNIX "local" est correctement configurée',
			'description' => 'Une connexion à un hôte distant, via SSH, est sans doute le moyen le plus sécurisé d\'accéder et d\'administrer à distance le serveur PostgreSQL. Une fois connecté au serveur PostgreSQL, à l\'aide du client psql, via UNIX DOMAIN SOCKETS, l\'utilisation de la méthode d\'authentification par les pairs constitue le mécanisme le plus sécurisé disponible pour les connexions à une base de données locale.',
		},
		'5.2' => {
			'title' => 'Vérifier que la connexion via le socket TCP/IP "hôte" est correctement configurée',
			'description' => 'Un grand nombre de méthodes d\'authentification sont disponibles pour les hôtes se connectant via des sockets TCP/IP. Les méthodes trust, password et ident ne doivent pas être utilisées pour les connexions à distance. La méthode md5 était autrefois la plus populaire et peut être utilisée dans des sessions chiffrées et non chiffrées. Cependant, elle est vulnérable aux attaques par relecture de paquets. Il est recommandé d\'utiliser scram-sha-256 à la place de md5. L\'utilisation des méthodes gss, sspi, pam, ldap, radius et cert dépend de la disponibilité de processus/services d\'authentification externes et n\'est donc pas couverte ici.',
		},
		'5.3' => {
			'title' => 'Vérifier que la complexité du mot de passe est configurée',
			'description' => 'Une gestion solide des mots de passe pour vos comptes PostgreSQL authentifiés localement vous protégera contre les techniques de force brute des attaquants. Ceci est particulièrement important si l\'authentification externe n\'est pas possible à mettre en œuvre en raison des exigences ou des restrictions de l\'application.',
		},
		'5.4' => {
			'title' => 'Vérifier que le délai d\'expiration et le délai d\'authentification sont bien configurés',
			'description' => 'Le délai d\'expiration de l\'authentification est le temps maximum autorisé pour terminer l\'authentification du client. Si un client potentiel n\'a pas terminé le protocole d\'authentification dans ce délai, le serveur ferme la connexion. Cela empêche les clients bloqués d\'occuper une connexion indéfiniment. Le délai d\'authentification entraîne une brève pause du serveur avant de signaler un échec d\'authentification, ce qui rend plus difficiles les attaques par force brute sur les mots de passe des bases de données. (*)',
		},
		'5.5' => {
			'title' => 'Vérifier que SSL est utilisé pour la connexion client',
			'description' => 'Toutes les connexions client distantes doivent être cryptées et les connexions non cryptées doivent être rejetées pour ne pas permettre le reniflage de données sur le réseau. (*)',
		},
		'5.6' => {
			'title' => 'Vérifier que les plages d\'adresses IP autorisées ne sont pas trop grandes',
			'description' => 'Autoriser une trop grande plage d\'adresses IP à se connecter au cluster PostgreSQL multiplie inutilement les risques. (*)',
		},
		'5.7' => {
			'title' => 'Vérifier que la base de données et les utilisateurs spécifiques sont utilisés',
			'description' => 'Le mot clé "all" dans la partie base de données et utilisateur des règles de pg_hba.conf peut permettre à n\'importe quel utilisateur de se connecter à n\'importe quelle base de données, il est recommandé de restreindre la connexion à un utilisateur et une base de données spécifiques. (*)',
		},
		'5.8' => {
			'title' => 'Vérifier que les superutilisateurs ne sont pas autorisés à se connecter à distance',
			'description' => 'Autoriser un superutilisateur PostgreSQL à se connecter à une base de données à partir d\'un hôte distant est dangereux, le mieux est d\'autoriser uniquement le(s) superutilisateur(s) à se connecter localement avec une authentification par un homologue. Si certains privilèges avancés sont requis, le mieux est d\'utiliser les rôles prédéfinis de PostgreSQL. (*)',
		},
		'5.9' => {
			'title' => 'Vérifier que \'password_encryption\' est positionné correctement.',
			'description' => 'PostgreSQL permet de définir l\'encryption utilisée pour le stockage des mots de passe, par défaut il est maintenant à \'scram-sha-256\' mais il pourrait être positionné à \'md5\' ce qui n\'est pas sécurisé. (*)',
		},
#-------------------------------
		'6' => {
			'title' => 'Paramètres PostgreSQL',
		},
		'6.1' => {
			'title' => 'Comprendre les vecteurs d\'attaque et les paramètres d\'exécution',
		},
		'6.2' => {
			'title' => 'Vérifier que les paramètres d\'exécution du \'backend\' sont correctement configurés',
			'description' => 'Un déni de service est possible en refusant l\'utilisation des index et en ralentissant l\'accès client à un niveau déraisonnable. Un comportement non autorisé peut être introduit en introduisant des bibliothèques malveillantes qui peuvent ensuite être appelées dans une session de base de données. La journalisation peut être modifiée et obscurcie, ce qui empêche l\'analyse des causes profondes. Toutes les modifications apportées à ce niveau affecteront le comportement global du serveur. Ces modifications ne peuvent être affectées que par un redémarrage du serveur après modification des paramètres dans les fichiers de configuration.',
		},
		'6.3' => {
			'title' => 'Vérifier que les paramètres d\'exécution de \'Postmaster\' sont correctement configurés',
			'description' => 'Le processus postmaster est le processus de supervision qui attribue un processus backend à une connexion client entrante. Le postmaster gère les paramètres d\'exécution clés qui sont soit partagés par toutes les connexions backend, soit nécessaires au processus postmaster lui-même pour s\'exécuter. Les paramètres suivants ne peuvent être définis au démarrage du serveur que par le propriétaire du processus et du cluster du serveur PostgreSQL, généralement le compte utilisateur UNIX postgres. Par conséquent, tous les exploits nécessitent la compromission réussie soit de ce compte UNIX, soit du compte superutilisateur Postgres lui-même.',
			'manuel' => 1,
		},
		'6.4' => {
			'title' => 'Vérifier que les paramètres d\'exécution de \'SIGHUP\' sont correctement configurés',
			'description' => 'Afin de définir le comportement du serveur et d\'optimiser ses performances, le superutilisateur du serveur a le privilège de définir ces paramètres qui se trouvent dans les fichiers de configuration postgresql.conf et pg_hba.conf. Alternativement, les paramètres trouvés dans postgresql.conf peuvent également être modifiés à l\'aide d\'une session de connexion au serveur et en exécutant la commande SQL ALTER SYSTEM qui écrit ses modifications dans le fichier de configuration postgresql.auto.conf. Toutes les modifications apportées à ce niveau affecteront le comportement global du serveur. Ces modifications peuvent être effectuées en éditant les fichiers de configuration de PostgreSQL et soit en exécutant un serveur SIGHUP à partir de la ligne de commande, soit, en tant que superutilisateur postgres, en exécutant la commande SQL select pg_reload_conf(). Un déni de service est possible en raison de la surallocation de ressources limitées, telles que la RAM. Les données peuvent être corrompues en permettant le chargement de pages endommagées ou en modifiant les paramètres pour réinterpréter les valeurs de manière inattendue, par exemple en modifiant le fuseau horaire. Les messages client peuvent être modifiés de manière à interférer avec la logique de l\'application. La journalisation peut être modifiée et obscurcie, empêchant ainsi l\'analyse des causes profondes.',
			'manuel' => 1,
		},
		'6.5' => {
			'title' => 'Vérifier que les paramètres d\'exécution du \'Superuser\' sont correctement configurés',
			'description' => 'Afin d\'améliorer et d\'optimiser les performances du serveur, le superutilisateur du serveur a le privilège de définir ces paramètres qui se trouvent dans le fichier de configuration postgresql.conf. Alternativement, ils peuvent être modifiés lors d\'une session de connexion PostgreSQL via la commande SQL ALTER SYSTEM qui écrit ses modifications dans le fichier de configuration postgresql.auto.conf. Toutes les modifications apportées à ce niveau affecteront le comportement global du serveur. Ces modifications ne peuvent être affectées que par un redémarrage du serveur après modification des paramètres dans les fichiers de configuration. Un déni de service est possible en raison de la surallocation de ressources limitées, telles que la RAM. Les données peuvent être corrompues en permettant le chargement de pages endommagées ou en modifiant les paramètres pour réinterpréter les valeurs de manière inattendue, par exemple en modifiant le fuseau horaire. Les messages client peuvent être modifiés de manière à interférer avec la logique de l\'application. La journalisation peut être modifiée et obscurcie, empêchant ainsi l\'analyse des causes profondes.',
			'manuel' => 1,
		},
		'6.6' => {
			'title' => 'Vérifier que les paramètres d\'exécution \'Utilisateur\' sont correctement configurés',
			'description' => 'Ces paramètres d\'exécution PostgreSQL sont gérés au niveau du compte utilisateur (ROLE). Afin d\'améliorer les performances et d\'optimiser les fonctionnalités, un ROLE a le privilège de définir de nombreux paramètres dans un attribut de transaction, de session ou d\'entité. N’importe quel RÔLE peut modifier n’importe lequel de ces paramètres. Un déni de service est possible en raison de la surallocation de ressources limitées, telles que la RAM. La modification des paramètres VACUUM peut forcer l\'arrêt du serveur, ce qui est une procédure standard empêchant la corruption des données due au bouclage de l\'ID de transaction. Les données peuvent être corrompues en modifiant les paramètres pour réinterpréter les valeurs de manière inattendue, par exemple en modifiant le fuseau horaire. La journalisation peut être modifiée et masquée pour empêcher l\'analyse des causes profondes.',
			'manuel' => 1,
		},
		'6.7' => {
			'title' => 'Vérifier que la cryptographie FIPS 140-2 OpenSSL est utilisée',
			'description' => 'Installer, configurer et utiliser OpenSSL sur une plate-forme disposant d\'une installation FIPS 140-2 d\'OpenSSL certifiée NIST. Cela donne aux instances PostgreSQL la possibilité de générer et de valider des hachages cryptographiques pour protéger les informations non classifiées nécessitant une confidentialité et une protection cryptographique, conformément aux exigences du propriétaire des données.',
		},
		'6.8' => {
			'title' => 'Vérifier que TLS est activé et configuré correctement',
			'description' => 'Si TLS n\'est pas activé et configuré correctement, cela augmente le risque de compromission des données lors du transit. Un certificat auto-signé peut être utilisé pour les tests, mais un certificat signé par une autorité de certification (CA) (soit l\'une des autorités de certification globales, soit une autorité locale) doit être utilisé en production afin que les clients puissent vérifier l\'identité du serveur. . Si tous les clients de base de données sont locaux dans l\'organisation, il est recommandé d\'utiliser une autorité de certification locale. Pour finalement activer et appliquer l\'authentification TLS pour le serveur, les enregistrements "hostssl" appropriés doivent être ajoutés au fichier pg_hba.conf.',
		},
		'6,9' => {
			'title' => 'Vérifier qu\'une extension cryptographique est installée',
			'description' => 'Les instances PostgreSQL traitant des données qui nécessitent des protections "données au repos" doivent utiliser des mécanismes cryptographiques pour empêcher la divulgation et la modification non autorisées des informations au repos. Ces mécanismes cryptographiques peuvent être natifs de PostgreSQL ou implémentés via un logiciel supplémentaire ou des paramètres de système d\'exploitation/système de fichiers, selon la situation.',
		},
		'7' => {
			'title' => 'Réplication',
		},
		'7.1' => {
			'title' => 'Vérifier qu\'un utilisateur réservé à la réplication est créé et utilisé pour la réplication en continu',
			'description' => 'Comme il n\'est pas nécessaire d\'être un superutilisateur pour initier une connexion de réplication, il convient de créer un compte spécifiquement pour la réplication. Cela permet de "verrouiller" davantage les utilisations du compte superutilisateur et suit le principe général d\'utiliser le moins de privilèges nécessaires.',
		},
		'7.2' => {
			'title' => 'Verifier que la journalisation des commandes de réplication est configurée',
			'description' => 'Une connexion de réplication réussie permet de décharger une copie complète des données stockées dans le cluster de données vers un autre hôte, potentiellement non sécurisé. En tant que tel, il est conseillé de consigner toutes les commandes de réplication exécutées dans votre cluster de bases de données pour garantir que les données ne sont pas déchargées vers un emplacement inattendu/indésirable.',
		},
		'7.3' => {
			'title' => 'Verifier que les sauvegardes de base sont configurées et fonctionnelles',
			'description' => 'Une \'sauvegarde de base\' est une copie du cluster de données de l\'hôte PRIMAIRE (PGDATA) et est utilisée pour créer des hôtes STANDBY et pour les mécanismes de récupération ponctuelle (PITR). Les sauvegardes de base doivent être copiées sur les réseaux de manière sécurisée à l\'aide d\'un mécanisme de transport crypté. La CLI PostgreSQL pg_basebackup peut être utilisée, cependant, le cryptage TLS doit être activé sur le serveur conformément à la section 6.8 de ce benchmark.',
		},
		'7.4' => {
			'title' => 'Verifier que l\'archivage WAL est configuré et fonctionnel',
			'description' => 'L\'archivage des journaux avec écriture anticipée (WAL), ou envoi des journaux, est le processus d\'envoi de fichiers journaux de transactions depuis l\'hôte PRIMAIRE vers un ou plusieurs hôtes DE VEILLE ou pour les archiver sur un périphérique de stockage distant pour une utilisation ultérieure. par exemple PITR. Il existe plusieurs utilitaires capables de copier des WAL, notamment, mais sans s\'y limiter, cp, scp, sftp et rynsc. Fondamentalement, le serveur suit un ensemble de paramètres d\'exécution qui définissent quand le WAL doit être copié à l\'aide de l\'un des utilitaires susmentionnés.',
		},
		'7.5' => {
			'title' => 'Vérifier que les paramètres de réplication en streaming sont correctement configurés',
			'description' => 'La réplication en streaming à partir d\'un hôte PRIMAIRE transmet des DDL, DML, des mots de passe et d\'autres activités et données potentiellement sensibles. Ces connexions doivent être protégées par Secure Sockets Layer (SSL). Vérifiez en STANDBY que Primary_conninfo contient \'sslmode=require sslcompression=1\'',
		},
		'8' => {
			'title' => 'Considérations spéciales sur la configuration',
			'description' => 'Les recommandations proposées ici tentent de répondre à certains des cas d\'utilisation les moins courants qui peuvent justifier des conseils/considérations supplémentaires en matière de configuration.',
		},
		'8.1' => {
			'title' => 'Vérifier que les emplacements des sous-répertoires PostgreSQL se trouvent en dehors du cluster de données',
			'description' => 'Ce rapport fait partie du chapitre "1.3 Garantir l\'initialisation réussie du cluster de données" .',
		},
		'8.2' => {
			'title' => 'Vérifier que l\'outil de sauvegarde et de restauration, \'pgBackRest\', est installé et configuré',
			'description' => 'La fonction de sauvegarde native de PostgreSQL pg_dump fournit des opérations de sauvegarde logiques adéquates mais ne fournit pas de récupération ponctuelle (PITR). La fonction PostgreSQL pg_basebackup effectue une sauvegarde physique des fichiers de base de données et fournit PITR, mais elle est limitée par un seul thread. Ces deux méthodologies sont standard dans l\'écosystème PostgreSQL et adaptées aux besoins particuliers de sauvegarde/récupération. pgBackRest offre une autre option avec des fonctionnalités et une flexibilité beaucoup plus robustes.',
		},
		'8.3' => {
			'title' => 'Verifier que les divers paramètres de configuration sont corrects',
			'description' => 'Cette recommandation couvre les fichiers spéciaux non réguliers et les bibliothèques dynamiques. PostgreSQL autorise les connexions locales via le SOCKET DE DOMAINE UNIX et, pour la plupart, toute personne disposant d\'un compte de connexion Unix légitime peut tenter cette tentative. Il est possible de limiter les tentatives de connexion à PostgreSQL en déplaçant le SOCKET DE DOMAINE UNIX vers un sous-répertoire avec des autorisations restreintes. La création et la mise en œuvre de bibliothèques dynamiques définies par l\'utilisateur constituent une capacité extraordinairement puissante. Entre les mains d\'un administrateur de base de données/programmeur expérimenté, il peut améliorer considérablement la puissance et la flexibilité du SGBDR ; mais un comportement nouveau et inattendu peut également être attribué au SGBDR, créant ainsi un environnement très dangereux dans lequel il faudrait autrement faire confiance.',
			'manuel' => 1,
		},
	},
);

1;

