package PGDSAT::Labels;
#------------------------------------------------------------------------------
# Project  : PostgreSQL Database Security Assement Tool
# Name     : PGDSAT/Labels.pm
# Language : Perl
# Authors  : Gilles Darold
# Copyright: Copyright (c) 2024-2026 HexaCluster Corp
# Function : Language module to import the securiy check description
#------------------------------------------------------------------------------
use vars qw($VERSION %AUDIT_LBL);
use strict;

$VERSION = '1.2';

%AUDIT_LBL = (
	'en_US' => {

		'1' => {
			'title' => 'Installation and Patches',
		},
		'1.1' => {
			'title' => 'Ensure packages are obtained from authorized repositories',
			'description' => 'Identify and inspect configured repositories to ensure they are all valid and authorized sources of packages.',
		},
		'1.1.1' => {
			'title' => 'PostgreSQL packages installed.',
			'description' => 'Inspect installed package to ensure they are all valid and authorized packages.',
			'manual' => 1,
		},
		'1.1.2' => {
			'title' => 'Ensure packages are obtained from PGDG',
			'description' => 'PostgreSQL packages not supported by the PostgreSQL community are generaly not recommended.',
		},
		'1.2' => {
			'title' => 'Ensure systemd Service Files Are Enabled',
			'description' => 'Check that the PostgreSQL systemd service is enabled. Enabling the systemd PostgreSQL service ensures that the database service is active when at system startup and reboot. This check is not done if Patroni is installed, in this case the start of PostgreSQL is handled by Patroni. (HexaCLuster)',
		},
		'1.3' => {
			'title' => 'Ensure Data Cluster Initialized Successfully',
			'description' => 'PostgreSQL enforces ownership and permissions of the data cluster such that the data cluster cannot be accessed by other UNIX user accounts and the data cluster cannot owned by root.',
		},
		'1.3.1' => {
			'title' => 'Check initialization of the PGDATA',
			'description' => 'The command initdb might have been run before starting PostgreSQL, verify that this is the case.',
		},
		'1.3.2' => {
			'title' => 'Check version in PGDATA',
			'description' => 'PostgreSQL maintain a file called PG_VERSION in the base directory, verify that .',
		},
		'1.3.3' => {
			'title' => 'Ensure Data Cluster have checksum enabled',
			'description' => 'When checksum are not enabled, silent data corruption can not be detected by PostgreSQL. Verify that they are enabled. (*)',
		},
		'1.3.4' => {
			'title' => 'Ensure WALs and temporary files are not on the same partition as the PGDATA',
			'description' => 'The PostgreSQL cluster is organized to carry out specific tasks in subdirectories. For the purposes of performance, reliability, and security some of these subdirectories should be relocated outside the data cluster. (*)',
		},
		'1.3.5' => {
			'title' => 'Ensure that the PGDATA partition is encrypted',
			'description' => 'PostgreSQL storage encryption can be performed at the file system level or the block level, for example using LUKS. This mechanism prevents unencrypted data from being read from the drives if the drives or the entire computer is stolen. This does not protect against attacks while the file system is mounted, because when mounted, the operating system provides an unencrypted view of the data. (*)',
			'manual' => 1,
		},
		'1.4' => {
		       'title' => 'Ensure PostgreSQL versions are up-to-date',
		       'descritption' => 'PostgreSQL minor upgrades contain only bugs and security fixes. There are no new features, new bugs and no compatibility problems with a minor upgrade, they are always fully binary compatible. You should always install minor releases as soon as they are published. For minor releases, the community considers not upgrading to be riskier than upgrading.',
	        },
		'1.5' => {
		       'title' => 'Ensure unused PostgreSQL extensions are removed',
		       'descritption' => 'PostgreSQL extensions are created in database, some may not be used anymore. This is a risk to keep unused extension installed in a database.',
			'manual' => 1,
	        },
		'1.6' => {
		       'title' => 'Ensure tablespace location is not inside the PGDATA',
		       'descritption' => 'Creating a tablespace in the data directory is useless and not recommended for performances reason and disk space use (*).',
	        },
#---------------------------
		'2' => {
			'title' => 'Directory and File Permissions',
		},
		'2.1' => {
			'title' => 'Ensure the file permissions mask is correct',
			'description' => 'The postgres system user should have a restrictive umask for file creation so that other UNIX users can not look at anything.',
		},
		'2.2' => {
			'title' => 'Check permissions of PGDATA',
			'description' => 'The data cluster Unix permissions must be 0700 (*).',
		},
		'2.3' => {
			'title' => 'List content of PGDATA to check unwanted files and symlinks',
			'description' => 'The content of the PGDATA must be generated by PostgreSQL itself except custom configuration files. (*).',
			'manual' => 1,
		},
		'2.4' => {
			'title' => 'Check permissions of pg_hba.conf',
			'description' => 'The pg_hba.conf UNIX permission must be 0640 or 0600, especially when it is stored outside the PGDATA (*).',
		},
		'2.5' => {
			'title' => 'Check permissions on Unix Socket',
			'description' => 'The default permissions are 0777, meaning anyone can connect. Reasonable alternatives are 0770 (only user and group, see also unix_socket_group) and 0700 (only user). (*).',
		},
#---------------------------
		'3' => {
			'title' => 'Logging And Auditing',
		},
		'3.1' => {
			'title' => 'PostgreSQL Logging',
			'description' => 'This section provides guidance with respect to PostgreSQL\'s logging behavior as it applies to security and auditing.',
		},
		'3.1.1' => {
			'title' => 'Logging Rationale',
			'description' => 'Having an audit trail is an important feature of any relational database system. You want enough detail to describe when an event of interest has started and stopped, what the event is/was, the event\'s cause, and what the event did/is doing to the system. Ideally, the logged information is in a format permitting further analysis giving us new perspectives and insight.',
		},
		'3.1.2' => {
			'title' => 'Ensure the log destinations are set correctly',
			'description' => 'If log_destination is not set, then any log messages generated by the core
PostgreSQL processes will be lost.',
		},
		'3.1.3' => {
			'title' => 'Ensure the logging collector is enabled',
			'description' => 'The logging collector approach is often more useful than logging to syslog, since some types of messages might not appear in syslog output. One common example is dynamic-linker failure message; another may be error messages produced by scripts such as archive_command.',
		},
		'3.1.4' => {
			'title' => 'Ensure the log file destination directory is set correctly',
			'description' => 'If log_directory is not set, it is interpreted as the absolute path \'/\' and PostgreSQL will attempt to write its logs there',
		},
		'3.1.5' => {
			'title' => 'Ensure the filename pattern for log files is set correctly',
			'description' => 'If log_filename is not set, then the value of log_directory is appended to an empty string and PostgreSQL will fail to start as it will try to write to a directory instead of a file.',
			'manual' => 1,
		},
		'3.1.6' => {
			'title' => 'Ensure the log file permissions are set correctly',
			'description' => 'Log files often contain sensitive data. Allowing unnecessary access to log files may inadvertently expose sensitive data to unauthorized personnel.',
		},
		'3.1.7' => {
			'title' => 'Ensure \'log_truncate_on_rotation\' is enabled',
			'description' => 'If this setting is disabled, pre-existing log files will be appended to if log_filename is configured in such a way that static or recurring names are generated.',
		},
		'3.1.8' => {
			'title' => 'Ensure the maximum log file lifetime is set correctly',
			'description' => 'Current best practices advise log rotation at least daily, but your organization\'s logging policy should dictate your rotation schedule.',
			'manual' => 1,
		},
		'3.1.9' => {
			'title' => 'Ensure the maximum log file size is set correctly',
			'description' => 'If this is set to zero, the size-triggered creation of new log files is disabled. This will prevent automatic log file rotation when files become too large, which could put log data at increased risk of loss (unless age-based rotation is configured).',
			'manual' => 1,
		},
		'3.1.10' => {
			'title' => 'Ensure the correct syslog facility is selected',
			'description' => 'If not set to the appropriate facility, the PostgreSQL log messages may be intermingled with other applications log messages, incorrectly routed, or potentially dropped (depending on your syslog configuration).',
			'manual' => 1,
		},
		'3.1.11' => {
			'title' => 'Ensure syslog messages are not suppressed',
			'description' => 'If disabled, messages sent to Syslog could be suppressed and not logged. While a message is emitted stating that a given message was repeated and suppressed, the timestamp associated with these suppressed messages is lost, potentially damaging the recreation of an incident timeline.',
		},
		'3.1.12' => {
			'title' => 'Ensure syslog messages are not lost due to size',
			'description' => 'Depending on the Syslog server in use, log messages exceeding 1024 bytes may be lost or, potentially, cause the Syslog server processes to abort.',
		},
		'3.1.13' => {
			'title' => 'Ensure the program name for PostgreSQL syslog messages is correct',
			'description' => 'If this is not set correctly, it may be difficult or impossible to distinguish PostgreSQL messages from other messages in Syslog logs.',
			'manual' => 1,
		},
		'3.1.14' => {
			'title' => 'Ensure the correct messages are written to the server log',
			'description' => 'If this is not set to the correct value, too many or too few messages may be written to the server log.',
		},
		'3.1.15' => {
			'title' => 'Ensure the correct SQL statements generating errors are recorded',
			'description' => 'If this is not set to the correct value, too many erring or too few erring SQL statements may be written to the server log.',
		},
		'3.1.16' => {
			'title' => 'Ensure \'debug_print_parse\' is disabled',
			'description' => 'Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.',
		},
		'3.1.17' => {
			'title' => 'Ensure \'debug_print_rewritten\' is disabled',
			'description' => 'Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.',
		},
		'3.1.18' => {
			'title' => 'Ensure \'debug_print_plan\' is disabled',
			'description' => 'Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.',
		},
		'3.1.19' => {
			'title' => 'Ensure \'debug_pretty_print\' is enabled',
			'description' => 'If this setting is disabled, the "compact" format is used instead, significantly reducing the readability of the DEBUG statement log messages.',
		},
		'3.1.20' => {
			'title' => 'Ensure \'log_connections\' is enabled',
			'description' => 'PostgreSQL does not maintain an internal record of attempted connections to the database for later auditing. It is only by enabling the logging of these attempts that one can determine if unexpected attempts are being made.',
		},
		'3.1.21' => {
			'title' => 'Ensure \'log_disconnections\' is enabled',
			'description' => 'PostgreSQL does not maintain the beginning or ending of a connection internally for later review. It is only by enabling the logging of these that one can examine connections for failed attempts, \'over long\' duration, or other anomalies.',
		},
		'3.1.22' => {
			'title' => 'Ensure \'log_error_verbosity\' is set correctly',
			'description' => 'If this is not set to the correct value, too many details or too few details may be logged.',
		},
		'3.1.23' => {
			'title' => 'Ensure \'log_hostname\' is set correctly',
			'description' => 'Depending on your hostname resolution setup, enabling this setting might impose a non-negligible performance penalty. Additionally, the IP addresses that are logged can be resolved to their DNS names when reviewing the logs (unless dynamic hostnames are being used as part of your DHCP setup).',
		},
		'3.1.24' => {
			'title' => 'Ensure \'log_line_prefix\' is set correctly',
			'description' => 'Properly setting log_line_prefix allows for adding additional information to each log entry (such as the user, or the database). Said information may then be of use in auditing or security reviews. The prefix should at least include \'%m [%p]: db=%d,user=%u,app=%a,client=%h \' (for logging to stderr) and for syslog logging, the prefix should include \'user=%u,db=%d,app=%a,client=%h \'.',
		},
		'3.1.25' => {
			'title' => 'Ensure \'log_statement\' is set correctly',
			'description' => 'Setting log_statement to align with your organization\'s security and logging policies facilitates later auditing and review of database activities.',
		},
		'3.1.26' => {
			'title' => 'Ensure \'log_timezone\' is set correctly',
			'description' => 'Log entry timestamps should be configured for an appropriate time zone as defined by your organization\'s logging policy to ensure a lack of confusion around when a logged event occurred.  Note that this setting affects only the timestamps present in the logs.',
		},
		'3.1.27' => {
			'title' => 'Ensure that log_directory is outside the PGDATA',
			'description' => 'Best practice is to not write PostgreSQL logs into the PGDATA for performances reason and disk space use. (*)',
		},
		'3.2' => {
			'title' => 'Ensure the PostgreSQL Audit Extension (pgAudit) is enabled',
			'description' => 'The PostgreSQL Audit Extension (pgAudit) provides detailed session and/or object audit logging via the standard PostgreSQL logging facility. The goal of pgAudit is to provide PostgreSQL users with the capability to produce audit logs often required to comply with government, financial, or ISO certifications.',
		},
#---------------------------
		'4' => {
			'title' => 'User Access and Authorization',
			'description' => 'These authorizations must be structured to block unauthorized use and/or corruption of vital data and services by setting restrictions on user capabilities.',
		},
		'4.1' => {
			'title' => 'Ensure sudo is configured correctly',
			'description' => 'Without sudo, there would be no capabilities to strictly control access to the superuser account nor to securely and authoritatively audit its use.',
			'manual' => 1,
		},
		'4.2' => {
			'title' => 'Ensure excessive administrative privileges are revoked',
			'description' => 'By not restricting global administrative commands to superusers only, regular users granted excessive privileges may execute administrative commands with unintended and undesirable results.',
		},
		'4.3' => {
			'title' => 'Ensure excessive function privileges are revoked',
			'description' => 'Functions in PostgreSQL can be created with the SECURITY DEFINER option. When SECURITY DEFINER functions are executed by a user, said function is run with the privileges of the user who created it, not the user who is running it. List of the functions with SECURITY DEFINER option not associated to an extension, per database.',
			'manual' => 1,
		},
		'4.4' => {
			'title' => 'Ensure excessive DML privileges are revoked',
			'description' => 'Excessive DML grants can lead to unprivileged users changing or deleting information without proper authorization.',
			'manual' => 1,
		},
		'4.5' => {
			'title' => 'Ensure Row Level Security (RLS) is configured correctly',
			'description' => 'If RLS policies and privileges are not configured correctly, users could perform actions on tables that they are not authorized to perform, such as inserting, updating, or deleting rows. List tables with RLS enabled.',
			'manual' => 1,
		},
		'4.6' => {
			'title' => 'Ensure the set_user extension is installed',
			'description' => 'Even when reducing and limiting the access to the superuser role, it is still difficult to determine who accessed the superuser role and what actions were taken using that role. As such, it is ideal to prevent anyone from logging in as the superuser and forcing them to escalate their role. The set_user extension allows for this setup.',
			'manual' => 1,
		},
		'4.7' => {
			'title' => 'Make use of predefined roles',
			'description' => 'In keeping with the principle of least privilege, judicious use of the PostgreSQL predefined roles can greatly limit the access to privileged, or superuser, access.',
			'manual' => 1,
		},
		'4.8' => {
			'title' => 'Ensure the public schema is protected',
			'description' => 'Privileges on the PostgreSQL default public schema must be restricted to some users, grant to public users must be removed or the schema dropped.',
		},
#---------------------------
		'5' => {
			'title' => 'Connection and Login',
			'description' => 'The restrictions on client/user connections to the PostgreSQL database blocks unauthorized access to data and services by setting access rules. These security measures help to ensure that successful logins cannot be easily made through brute-force password attacks, replaying the password hash, or intuited by clever social engineering exploits.',
		},
		'5.1' => {
			'title' => 'Ensure login via "local" UNIX Domain Socket is configured correctly',
			'description' => 'A remote host login, via SSH, is arguably the most secure means of remotely accessing and administering the PostgreSQL server. Once connected to the PostgreSQL server, using the psql client, via UNIX DOMAIN SOCKETS, while using the peer authentication method is the most secure mechanism available for local database connections.',
		},
		'5.2' => {
			'title' => 'Ensure login via "host" TCP/IP Socket is configured correctly',
			'description' => 'A large number of authentication methods are available for hosts connecting using TCP/IP sockets. Methods trust, password, and ident are not to be used for remote logins. Method md5 used to be the most popular and can be used in both encrypted and unencrypted sessions, however, it is vulnerable to packet replay attacks. It is recommended that scram-sha-256 be used instead of md5. Use of the gss, sspi, pam, ldap, radius, and cert methods are dependent upon the availability of external authenticating processes/services and thus are not covered here.',
		},
		'5.3' => {
			'title' => 'Ensure Password Complexity is configured',
			'description' => 'Having strong password management for your locally-authenticated PostgreSQL accounts will protect against attackers\' brute force techniques. This is important especially if external authentication is not possible to implement due to application requirements or restrictions.',
		},
		'5.4' => {
			'title' => 'Ensure authentication timeout and delay are well configured',
			'description' => 'Authentication timeout is the maximum amount of time allowed to complete client authentication. If a would-be client has not completed the authentication protocol in this much time, the server closes the connection. This prevents hung clients from occupying a connection indefinitely. Authentication delay causes the server to pause briefly before reporting authentication failure, to make brute-force attacks on database passwords more difficult. (*)',
		},
		'5.5' => {
			'title' => 'Ensure SSL is used for client connection',
			'description' => 'All remote client connection should be encrypted and non encrypted connexion  should be reject to not permit data sniffing on the network. (*)',
		},
		'5.6' => {
			'title' => 'Ensure authorized Ip addresses ranges are not too large',
			'description' => 'Allowing a too large range of Ip addresses to connect to PostgreSQL cluster multiply the risks unnecessarily. (*)',
		},
		'5.7' => {
			'title' => 'Ensure specific database and users are used',
			'description' => 'The keyword "all" in the database and user part of the pg_hba.conf rules can allow any user to connect to any database, it is recommended to restrict the connection to specific user and database. (*)',
		},
		'5.8' => {
			'title' => 'Ensure superusers are not allowed to connect remotely',
			'description' => 'Allowing a PostgreSQL superuser to connect to a database from a remote host is dangerous, best is to only allow the superuser(s) to connect locally with a peer authentication. If some advanced privileges are required, best is to use the PostgreSQL predefined roles. (*)',
		},
		'5.9' => {
			'title' => 'Ensure that \'password_encryption\' is correctly set',
			'description' => 'PostgreSQL allow to set password encryption, default is now \'scram-sha-256\' but it can be set to \'md5\' which is insecure. (*)',
		},
#---------------------------
		'6' => {
			'title' => 'PostgreSQL Settings',
		},
		'6.1' => {
			'title' => 'Understanding attack vectors and runtime parameters',
		},
		'6.2' => {
			'title' => 'Ensure \'backend\' runtime parameters are configured correctly',
			'description' => 'A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis. All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.',
		},
		'6.3' => {
			'title' => 'Ensure \'Postmaster\' runtime parameters are configured correctly',
			'description' => 'The postmaster process is the supervisory process that assigns a backend process to an incoming client connection. The postmaster manages key runtime parameters that are either shared by all backend connections or needed by the postmaster process itself to run. The following parameters can only be set at server start by the owner of the PostgreSQL server process and cluster, typically the UNIX user account postgres.  Therefore, all exploits require the successful compromise of either that UNIX account or the postgres superuser account itself.',
			'manual' => 1,
		},
		'6.4' => {
			'title' => 'Ensure \'SIGHUP\' runtime parameters are configured correctly',
			'description' => 'In order to define server behavior and optimize server performance, the server\'s superuser has the privilege of setting these parameters which are found in the configuration files postgresql.conf and pg_hba.conf. Alternatively, those parameters found in postgresql.conf can also be changed using a server login session and executing the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf. All changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.',
			'manual' => 1,
		},
		'6.5' => {
			'title' => 'Ensure \'Superuser\' runtime parameters are configured correctly',
			'description' => 'In order to improve and optimize server performance, the server\'s superuser has the privilege of setting these parameters which are found in the configuration file postgresql.conf. Alternatively, they can be changed in a PostgreSQL login session via the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf. All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files. A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.',
			'manual' => 1,
		},
		'6.6' => {
			'title' => 'Ensure \'User\' runtime parameters are configured correctly',
			'description' => 'These PostgreSQL runtime parameters are managed at the user account (ROLE) level. In order to improve performance and optimize features, a ROLE has the privilege of setting numerous parameters in a transaction, session, or entity attribute. Any ROLE can alter any of these parameters. A denial of service is possible by the over-allocating of limited resources, such as RAM.  Changing VACUUM parameters can force a server shutdown which is standard procedure preventing data corruption from transaction ID wraparound. Data can be corrupted by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Logging can be altered and obfuscated to inhibit root cause analysis.',
			'manual' => 1,
		},
		'6.7' => {
			'title' => 'Ensure FIPS 140-2 OpenSSL cryptography is used',
			'description' => 'Install, configure, and use OpenSSL on a platform that has a NIST certified FIPS 140-2 installation of OpenSSL. This provides PostgreSQL instances the ability to generate and validate cryptographic hashes to protect unclassified information requiring confidentiality and cryptographic protection, in accordance with the data owner\'s requirements.',
		},
		'6.8' => {
			'title' => 'Ensure TLS is enabled and configured correctly',
			'description' => 'If TLS is not enabled and configured correctly, this increases the risk of data being compromised in transit. A self-signed certificate can be used for testing, but a certificate signed by a certificate authority (CA) (either one of the global CAs or a local one) should be used in production so that clients can verify the server\'s identity. If all the database clients are local to the organization, using a local CA is recommended. To ultimately enable and enforce TLS authentication for the server, appropriate "hostssl" records must be added to the pg_hba.conf file.',
		},
		'6.9' => {
			'title' => 'Ensure a cryptographic extension is installed',
			'description' => 'PostgreSQL instances handling data that requires "data at rest" protections must employ cryptographic mechanisms to prevent unauthorized disclosure and modification of the information at rest. These cryptographic mechanisms may be native to PostgreSQL or implemented via additional software or operating system/file system settings, as appropriate to the situation.',
		},
		'6.10' => {
			'title' => 'Ensure a data anonymization extension is installed',
			'description' => 'To mask or replace information that could permit to identify a person or to prevent exposing sensitive data, a data anomymization extension should be installed on the PostgreSQL cluster. Check that extensions pg_anonymize or anon are set in \'session_preload_libraries\' (*).',
		},
		'7' => {
			'title' => 'Replication',
		},
		'7.1' => {
			'title' => 'Ensure a replication-only user is created and used for streaming replication',
			'description' => 'As it is not necessary to be a superuser to initiate a replication connection, it is proper to create an account specifically for replication. This allows further "locking down" the uses of the superuser account and follows the general principle of using the least privileges necessary.',
		},
		'7.2' => {
			'title' => 'Ensure logging of replication commands is configured',
			'description' => 'A successful replication connection allows for a complete copy of the data stored within the data cluster to be offloaded to another, potentially insecure, host. As such, it is advisable to log all replication commands that are executed in your database cluster to ensure the data is not off-loaded to an unexpected/undesired location.',
		},
		'7.3' => {
			'title' => 'Ensure base backups are configured and functional',
			'description' => 'A \'base backup\' is a copy of the PRIMARY host\'s data cluster (PGDATA) and is used to create STANDBY hosts and for Point In Time Recovery (PITR) mechanisms. Base backups should be copied across networks in a secure manner using an encrypted transport mechanism. The PostgreSQL CLI pg_basebackup can be used, however, TLS encryption should be enabled on the server as per section 6.8 of this benchmark.',
		},
		'7.4' => {
			'title' => 'Ensure WAL archiving is configured and functional',
			'description' => 'Write Ahead Log (WAL) Archiving, or Log Shipping, is the process of sending transaction log files from the PRIMARY host either to one or more STANDBY hosts or to be archived on a remote storage device for later use, e.g. PITR. There are several utilities that can copy WALs including, but not limited to, cp, scp, sftp, and rynsc. Basically, the server follows a set of runtime parameters which define when the WAL should be copied using one of the aforementioned utilities.',
		},
		'7.5' => {
			'title' => 'Ensure streaming replication parameters are configured correctly',
			'description' => 'Streaming replication from a PRIMARY host transmits DDL, DML, passwords, and other potentially sensitive activities and data. These connections should be protected with Secure Sockets Layer (SSL). Verify on STANDBY that primary_conninfo contains \'sslmode=require sslcompression=1\'',
		},
		'8' => {
			'title' => 'Special Configuration Considerations',
			'description' => 'The recommendations proposed here try to address some of the less common use cases which may warrant additional configuration guidance/consideration.',
		},
		'8.1' => {
			'title' => 'Ensure PostgreSQL subdirectory locations are outside the data cluster',
			'description' => 'This report is part of chapter <a href="#1.3">"1.3 Ensure Data Cluster Initialized Successfully"</a>.',
		},
		'8.2' => {
			'title' => 'Ensure the backup and restore tool, \'pgBackRest\', is installed and configured',
			'description' => 'The native PostgreSQL backup facility pg_dump provides adequate logical backup operations but does not provide for Point In Time Recovery (PITR). The PostgreSQL facility pg_basebackup performs a physical backup of the database files and does provide for PITR, but it is constrained by single threading. Both of these methodologies are standard in the PostgreSQL ecosystem and appropriate for particular backup/recovery needs. pgBackRest offers another option with much more robust features and flexibility.',
		},
		'8.3' => {
			'title' => 'Ensure miscellaneous configuration settings are correct',
			'description' => 'This recommendation covers non-regular, special files, and dynamic libraries. PostgreSQL permits local logins via the UNIX DOMAIN SOCKET and, for the most part, anyone with a legitimate Unix login account can make the attempt. Limiting PostgreSQL login attempts can be made by relocating the UNIX DOMAIN SOCKET to a subdirectory with restricted permissions. The creation and implementation of user-defined dynamic libraries is an extraordinary powerful capability. In the hands of an experienced DBA/programmer, it can significantly enhance the power and flexibility of the RDBMS; but new and unexpected behavior can also be assigned to the RDBMS, resulting in a very dangerous environment in what should otherwise be trusted.',
			'manual' => 1,
		},
	},

#------------------------------------------------------------------------------------------------------
	'fr_FR' => {
#------------------------------------------------------------------------------------------------------

		'1' => {
			'title' => 'Installation et correctifs',
		},
		'1.1' => {
			'title' => 'Vérifier que les packages sont obtenus à partir de dépots autorisés',
			'description' => 'Identifiez et inspectez les dépots configurés pour vous assurer qu\'ils constituent tous des sources de packages valides et autorisées.',
		},
		'1.1.1' => {
			'title' => 'Paquets PostgreSQL installés.',
			'description' => 'Inspectez les packages installés pour vous assurer qu\'ils sont tous des packages valides et autorisés.',
			'manuel' => 1,
		},
		'1.1.2' => {
			'title' => 'Vérifier que les packages sont obtenus auprès de PGDG',
			'description' => 'Les packages PostgreSQL non pris en charge par la communauté PostgreSQL ne sont généralement pas recommandés.',
		},
		'1.2' => {
			'title' => 'Vérifier que les fichiers du service systemd sont activés',
			'description' => 'Vérifiez que le service systemd PostgreSQL est activé. L\'activation du service systemd PostgreSQL garantit que le service de base de données est actif au démarrage et au redémarrage du système. Cette vérification n\'est pas effectuée si Patroni est installé, dans ce cas le démarrage de PostgreSQL est géré par Patroni. (HexaCLustre)',
		},
		'1.3' => {
			'title' => 'Vérifier l\'initialisation réussie du cluster de données',
			'description' => 'PostgreSQL applique la propriété et les autorisations du cluster de données de telle sorte que le cluster de données ne soit pas accessible par d\'autres comptes utilisateurs UNIX et que le cluster de données ne puisse pas appartenir à root.',
		},
		'1.3.1' => {
			'title' => 'Vérifier l\'initialisation du PGDATA',
			'description' => 'La commande initdb a peut-être été exécutée avant de démarrer PostgreSQL, vérifiez que c\'est le cas.',
		},
		'1.3.2' => {
			'title' => 'Vérifier la version dans PGDATA',
			'description' => 'PostgreSQL maintient un fichier appelé PG_VERSION dans le répertoire de base, vérifiez que .',
		},
		'1.3.3' => {
			'title' => 'Verifier que les checksum du cluster de données est activée',
			'description' => 'Lorsque les checksum ne sont pas activées, la corruption silencieuse des données ne peut pas être détectée par PostgreSQL. Vérifiez qu\'ils sont activés. (*)',
		},
		'1.3.4' => {
			'title' => 'Vérifier que les WAL et les fichiers temporaires ne se trouvent pas sur la même partition que PGDATA',
			'description' => 'Le cluster PostgreSQL est organisé pour effectuer des tâches spécifiques dans des sous-répertoires. Pour des raisons de performances, de fiabilité et de sécurité, certains de ces sous-répertoires doivent être déplacés en dehors du cluster de données. (*)',
		},
		'1.3.5' => {
			'title' => 'Vérifier que la partition PGDATA est chiffrée',
			'description' => 'Le chiffrement du stockage PostgreSQL peut être effectué au niveau du système de fichiers ou au niveau du bloc, par exemple en utilisant LUKS. Ce mécanisme empêche la lecture de données non cryptées sur les disques en cas de vol des disques ou de l\'intégralité de l\'ordinateur. Cela ne protège pas contre les attaques pendant le montage du système de fichiers, car une fois monté, le système d\'exploitation fournit une vue non chiffrée des données. (*)',
			'manuel' => 1,
		},
		'1.4' => {
		       'title' => 'Vérifier que les versions de PostgreSQL sont à jour',
		       'descritption' => 'Les mises à jour mineures de PostgreSQL contiennent uniquement des correctifs de bugs et de sécurité. Il n\'y a pas de nouvelles fonctionnalités, de nouveaux bugs et aucun problème de compatibilité avec une mise à jour mineure, ils sont toujours entièrement binaires compatibles. Vous devez toujours installer les versions mineures dès qu\'elles sont publiées. Pour les versions mineures, la communauté considère que ne pas mettre à niveau est plus risqué que la mise à niveau.',
	        },
		'1.5' => {
		       'title' => 'Vérifier que les extensions PostgreSQL inutilisées sont supprimées',
		       'descritption' => 'Les extensions PostgreSQL sont créées dans la base de données, certaines ne peuvent plus être utilisées. Il est risqué de conserver les extensions inutilisées installées dans une base de données.',
			'manuel' => 1,
	        },
		'1.6' => {
		       'title' => 'Vérifier que la destination des tablespaces n\'est pas dans le PGDATA',
		       'descritption' => 'Créer un tablespace dans le répertoire des données est inutile est absoluement pas recommendé pour des raisons de performances et d\'utilisation d\'espace disque (*).',
	        },
#-------------------------------
		'2' => {
			'title' => 'Autorisations de répertoire et de fichier',
		},
		'2.1' => {
			'title' => 'Vérifier que le masque d\'autorisations du fichier est correct',
			'description' => 'L\'utilisateur du système postgres doit avoir un umask restrictif pour la création de fichiers afin que les autres utilisateurs UNIX ne puissent rien voir.',
		},
		'2.2' => {
			'title' => 'Vérifier les autorisations de PGDATA',
			'description' => 'Les autorisations Unix du cluster de données doivent être 0700 (*).',
		},
		'2.3' => {
			'title' => 'Liste du contenu de PGDATA pour vérifier les fichiers et liens symboliques indésirables',
			'description' => 'Le contenu du PGDATA doit être généré par PostgreSQL lui-même, à l\'exception des fichiers de configuration personnalisés. (*).',
			'manuel' => 1,
		},
		'2.4' => {
			'title' => 'Vérifier les autorisations de pg_hba.conf',
			'description' => 'La permission UNIX pg_hba.conf doit être 0640 ou 0600, surtout lorsqu\'elle est stockée en dehors du PGDATA (*).',
		},
		'2.5' => {
			'title' => 'Vérifier les autorisations de la socket Unix',
			'description' => 'Les permissions par défaut sont 0777, ce qui veut dire que tout le monde peut se connecter. Une alternative raisonnable est 0770 (seulement l\'utilisateur et le groupe Unix, voir aussi unix_socket_group) at 0700 (l\'utilisateur seulement). (*).',
		},
#-------------------------------
		'3' => {
			'title' => 'Journalisation et audit',
		},
		'3.1' => {
			'title' => 'Journalisation PostgreSQL',
			'description' => 'Cette section fournit des conseils concernant le comportement de journalisation de PostgreSQL tel qu\'il s\'applique à la sécurité et à l\'audit.',
		},
		'3.1.1' => {
			'title' => 'Raison d\'être de la journalisation',
			'description' => 'Avoir une piste d\'audit est une caractéristique importante de tout système de base de données relationnelle. Vous voulez suffisamment de détails pour décrire quand un événement qui vous intéresse a commencé et s\'est arrêté, ce qu\'est l\'événement, sa cause et ce que l\'événement a fait au système. Idéalement, les informations enregistrées sont dans un format permettant une analyse plus approfondie nous donnant de nouvelles perspectives et informations.',
		},
		'3.1.2' => {
			'title' => 'Vérifier que les destinations des fichiers de log sont correctement définies',
			'description' => 'Si log_destination n\'est pas défini, alors tous les messages de journal générés par le noyau Les processus PostgreSQL seront perdus.',
		},
		'3.1.3' => {
			'title' => 'Vérifier que le collecteur de journaux est activé',
			'description' => 'L\'utilisation du collecteur de logs est souvent plus utile que la journalisation sur Syslog, car certains types de messages peuvent ne pas apparaître dans la sortie Syslog. Un exemple courant est le message d\'échec de l\'éditeur de liens dynamiques ; un autre peut être des messages d\'erreur produits par des scripts tels que archive_command.',
		},
		'3.1.4' => {
			'title' => 'Vérifier que le répertoire de destination des journaux est correctement défini',
			'description' => 'Si log_directory n\'est pas défini, il est interprété comme le chemin absolu \'/\' et PostgreSQL tentera d\'y écrire ses journaux',
		},
		'3.1.5' => {
			'title' => 'Vérifier que le modèle de nom de fichier pour les journaux est correctement défini',
			'description' => 'Si log_filename n\'est pas défini, alors la valeur de log_directory est ajoutée à une chaîne vide et PostgreSQL ne parviendra pas à démarrer car il tentera d\'écrire dans un répertoire au lieu d\'un fichier.',
			'manuel' => 1,
		},
		'3.1.6' => {
			'title' => 'Vérifier que les autorisations du fichier journal sont correctement définies',
			'description' => 'Les fichiers journaux contiennent souvent des données sensibles. Autoriser un accès inutile aux fichiers journaux peut exposer par inadvertance des données sensibles à du personnel non autorisé.',
		},
		'3.1.7' => {
			'title' => 'Vérifier que \'log_truncate_on_rotation\' est activé',
			'description' => 'Si ce paramètre est désactivé, les fichiers journaux préexistants seront ajoutés si log_filename est configuré de telle manière que des noms statiques ou récurrents soient générés.',
		},
		'3.1.8' => {
			'title' => 'Vérifier que la durée de vie maximale du fichier journal est correctement définie',
			'description' => 'Les meilleures pratiques actuelles conseillent une rotation des journaux au moins quotidiennement, mais la politique de journalisation de votre organisation doit dicter votre calendrier de rotation.',
			'manuel' => 1,
		},
		'3.1.9' => {
			'title' => 'Vérifier que la taille maximale du fichier journal est correctement définie',
			'description' => 'Si cette valeur est définie sur zéro, la création de nouveaux fichiers journaux déclenchée par la taille est désactivée. Cela empêchera la rotation automatique des fichiers journaux lorsque les fichiers deviennent trop volumineux, ce qui pourrait exposer les données des journaux à un risque accru de perte (à moins que la rotation basée sur l\'âge ne soit configurée).',
			'manuel' => 1,
		},
		'3.1.10' => {
			'title' => 'Vérifier que la bonne fonction Syslog est sélectionnée',
			'description' => 'S\'ils ne sont pas définis sur la fonction appropriée, les messages du journal PostgreSQL peuvent être mélangés avec les messages du journal d\'autres applications, mal acheminés ou potentiellement supprimés (en fonction de votre configuration syslog).',
			'manuel' => 1,
		},
		'3.1.11' => {
			'title' => 'Vérifier que les messages Syslog ne sont pas supprimés',
			'description' => 'Si désactivé, les messages envoyés à Syslog pourraient être supprimés et non enregistrés. Lorsqu\'un message est émis indiquant qu\'un message donné a été répété et supprimé, l\'horodatage associé à ces messages supprimés est perdu, ce qui peut potentiellement endommager la recréation d\'une chronologie d\'incident.',
		},
		'3.1.12' => {
			'title' => 'Vérifier que les messages Syslog ne sont pas perdus en raison de leur taille',
			'description' => 'En fonction du serveur Syslog utilisé, les messages de journal dépassant 1024 octets peuvent être perdus ou, potentiellement, provoquer l\'abandon des processus du serveur Syslog.',
		},
		'3.1.13' => {
			'title' => 'Vérifier que le nom du programme pour les messages syslog PostgreSQL est correct',
			'description' => 'Si ceci n\'est pas défini correctement, il peut être difficile, voire impossible, de distinguer les messages PostgreSQL des autres messages dans les journaux Syslog.',
			'manuel' => 1,
		},
		'3.1.14' => {
			'title' => 'Vérifier que les messages corrects sont écrits dans le journal du serveur',
			'description' => 'Si la valeur n\'est pas correcte, trop ou pas assez de messages peuvent être écrits dans le journal du serveur.',
		},
		'3.1.15' => {
			'title' => 'Vérifier que les instructions SQL correctes générant des erreurs sont enregistrées',
			'description' => 'Si la valeur n\'est pas correcte, trop ou pas assez d\'instructions SQL erronées peuvent être écrites dans le journal du serveur.',
		},
		'3.1.16' => {
			'title' => 'Vérifier que \'debug_print_parse\' est désactivé',
			'description' => 'L\'activation de l\'une des variables d\'impression DEBUG peut entraîner la journalisation d\'informations sensibles qui seraient autrement omises en fonction de la configuration des autres paramètres de journalisation.',
		},
		'3.1.17' => {
			'title' => 'Vérifier que \'debug_print_rewriting\' est désactivé',
			'description' => 'L\'activation de l\'une des variables d\'impression DEBUG peut entraîner la journalisation d\'informations sensibles qui seraient autrement omises en fonction de la configuration des autres paramètres de journalisation.',
		},
		'3.1.18' => {
			'title' => 'Vérifier que \'debug_print_plan\' est désactivé',
			'description' => 'L\'activation de l\'une des variables d\'impression DEBUG peut entraîner la journalisation d\'informations sensibles qui seraient autrement omises en fonction de la configuration des autres paramètres de journalisation.',
		},
		'3.1.19' => {
			'title' => 'Vérifier que \'debug_pretty_print\' est activé',
			'description' => 'Si ce paramètre est désactivé, le format "compact" est utilisé à la place, réduisant considérablement la lisibilité des messages du journal de l\'instruction DEBUG.',
		},
		'3.1.20' => {
			'title' => 'Vérifier que \'log_connections\' est activé',
			'description' => 'PostgreSQL ne conserve pas d\'enregistrement interne des tentatives de connexion à la base de données pour un audit ultérieur. Ce n\'est qu\'en activant la journalisation de ces tentatives que l\'on peut déterminer si des tentatives inattendues sont effectuées.',
		},
		'3.1.21' => {
			'title' => 'Vérifier que \'log_disconnections\' est activé',
			'description' => 'PostgreSQL ne conserve pas le début ou la fin d\'une connexion en interne pour une révision ultérieure. Ce n\'est qu\'en activant la journalisation de ces connexions que l\'on peut examiner les connexions à la recherche de tentatives infructueuses, de durées « de longue durée » ou d\'autres anomalies.',
		},
		'3.1.22' => {
			'title' => 'Vérifier que \'log_error_verbosity\' est correctement défini',
			'description' => 'Si la valeur n\'est pas correcte, trop ou pas assez de détails peuvent être enregistrés.',
		},
		'3.1.23' => {
			'title' => 'Vérifier que \'log_hostname\' est correctement défini',
			'description' => 'En fonction de la configuration de votre résolution de nom d\'hôte, l\'activation de ce paramètre peut imposer une pénalité de performances non négligeable. De plus, les adresses IP enregistrées peuvent être résolues en leurs noms DNS lors de l\'examen des journaux (sauf si des noms d\'hôte dynamiques sont utilisés dans le cadre de votre configuration DHCP).',
		},
		'3.1.24' => {
			'title' => 'Vérifier que \'log_line_prefix\' est correctement défini',
			'description' => 'Un réglage correct de log_line_prefix permet d\'ajouter des informations supplémentaires à chaque entrée de journal (telle que l\'utilisateur ou la base de données). Ces informations peuvent alors être utiles dans le cadre d’audits ou d’examens de sécurité. Le préfixe doit au moins inclure \'%m [%p] : db=%d,user=%u,app=%a,client=%h \' (pour la journalisation sur stderr) et pour la journalisation syslog, le préfixe doit inclure \'user=%u,db=%d,app=%a,client=%h \'.',
		},
		'3.1.25' => {
			'title' => 'Vérifier que \'log_statement\' est correctement défini',
			'description' => 'Configurer log_statement pour qu\'il s\'aligne sur les politiques de sécurité et de journalisation de votre organisation facilite l\'audit et l\'examen ultérieurs des activités de la base de données.',
		},
		'3.1.26' => {
			'title' => 'Vérifier que \'log_timezone\' est correctement défini',
			'description' => 'Les horodatages des entrées de journal doivent être configurés pour un fuseau horaire approprié tel que défini par la politique de journalisation de votre organisation afin de garantir l\'absence de confusion quant au moment où un événement enregistré s\'est produit. Notez que ce paramètre affecte uniquement les horodatages présents dans les journaux.',
		},
		'3.1.27' => {
			'title' => 'Vérifier que log_directory est en dehors de PGDATA',
			'description' => 'La meilleure pratique consiste à ne pas écrire de journaux PostgreSQL dans PGDATA pour des raisons de performances et d\'utilisation de l\'espace disque. (*)',
		},
		'3.2' => {
			'title' => 'Vérifier que l\'extension d\'audit PostgreSQL (pgAudit) est activée',
			'description' => 'L\'extension d\'audit PostgreSQL (pgAudit) fournit une journalisation détaillée de l\'audit de session et/ou d\'objet via la fonction de journalisation standard de PostgreSQL. L\'objectif de pgAudit est de fournir aux utilisateurs de PostgreSQL la capacité de produire des journaux d\'audit souvent requis pour se conformer aux certifications gouvernementales, financières ou ISO.',
		},
#-------------------------------
		'4' => {
			'title' => 'Accès utilisateur et autorisation',
			'description' => 'Ces autorisations doivent être structurées pour bloquer l\'utilisation non autorisée et/ou la corruption de données et de services vitaux en définissant des restrictions sur les capacités des utilisateurs.',
		},
		'4.1' => {
			'title' => 'Vérifier que sudo est correctement configuré',
			'description' => 'Sans sudo, il n\'y aurait aucune possibilité de contrôler strictement l\'accès au compte superutilisateur ni d\'auditer son utilisation de manière sécurisée et faisant autorité.',
			'manuel' => 1,
		},
		'4.2' => {
			'title' => 'Verifier que les privilèges administratifs excessifs soient révoqués',
			'description' => 'En ne limitant pas les commandes d\'administration globales aux superutilisateurs uniquement, les utilisateurs réguliers bénéficiant de privilèges excessifs peuvent exécuter des commandes d\'administration avec des résultats involontaires et indésirables.',
		},
		'4.3' => {
			'title' => 'Verifier que les privilèges de fonction excessifs soient révoqués',
			'description' => 'Des fonctions dans PostgreSQL peuvent être créées avec l\'option SECURITY DEFINER. Lorsque les fonctions SECURITY DEFINER sont exécutées par un utilisateur, ladite fonction est exécutée avec les privilèges de l\'utilisateur qui l\'a créée, et non de celui qui l\'exécute. Liste des fonctions avec option SECURITY DEFINER non associées à une extension, par base de données.',
			'manuel' => 1,
		},
		'4.4' => {
			'title' => 'Vérifier que les privilèges DML excessifs sont révoqués',
			'description' => 'Des autorisations DML excessives peuvent amener des utilisateurs non privilégiés à modifier ou à supprimer des informations sans autorisation appropriée.',
			'manuel' => 1,
		},
		'4.5' => {
			'title' => 'Vérifier que la sécurité au niveau des lignes (RLS) est correctement configurée',
			'description' => 'Si les politiques et privilèges RLS ne sont pas configurés correctement, les utilisateurs peuvent effectuer des actions sur les tables qu\'ils ne sont pas autorisés à effectuer, telles que l\'insertion, la mise à jour ou la suppression de lignes. Liste les tables avec RLS activé.',
			'manuel' => 1,
		},
		'4.6' => {
			'title' => 'Vérifier que l\'extension set_user est installée',
			'description' => 'Même en réduisant et en limitant l\'accès au rôle de superutilisateur, il reste difficile de déterminer qui a accédé au rôle de superutilisateur et quelles actions ont été entreprises en utilisant ce rôle. En tant que tel, il est idéal d’empêcher quiconque de se connecter en tant que superutilisateur et de le forcer à élever son rôle. L\'extension set_user permet cette configuration.',
			'manuel' => 1,
		},
		'4.7' => {
			'title' => 'Utiliser des rôles prédéfinis',
			'description' => 'Conformément au principe du moindre privilège, une utilisation judicieuse des rôles prédéfinis de PostgreSQL peut limiter considérablement l\'accès aux accès privilégiés ou superutilisateur.',
			'manuel' => 1,
		},
		'4.8' => {
			'title' => 'Vérifier que le schéma public ne peut pas être utilsé',
			'description' => 'Les privilèges sur le schéma public créé par PostgreSQL par défault doivent être restreints à certains utilisateurs ou supprimé.',
		},
#-------------------------------
		'5' => {
			'title' => 'Connexion et connexion',
			'description' => 'Les restrictions sur les connexions client/utilisateur à la base de données PostgreSQL bloquent l\'accès non autorisé aux données et services en définissant des règles d\'accès. Ces mesures de sécurité contribuent à garantir que les connexions réussies ne peuvent pas être facilement réalisées par le biais d\'attaques de mot de passe par force brute, par la relecture du hachage du mot de passe ou par des exploits d\'ingénierie sociale intelligents.',
		},
		'5.1' => {
			'title' => 'Vérifier que la connexion via le socket de domaine UNIX "local" est correctement configurée',
			'description' => 'Une connexion à un hôte distant, via SSH, est sans doute le moyen le plus sécurisé d\'accéder et d\'administrer à distance le serveur PostgreSQL. Une fois connecté au serveur PostgreSQL, à l\'aide du client psql, via UNIX DOMAIN SOCKETS, l\'utilisation de la méthode d\'authentification par les pairs constitue le mécanisme le plus sécurisé disponible pour les connexions à une base de données locale.',
		},
		'5.2' => {
			'title' => 'Vérifier que la connexion via le socket TCP/IP "hôte" est correctement configurée',
			'description' => 'Un grand nombre de méthodes d\'authentification sont disponibles pour les hôtes se connectant via des sockets TCP/IP. Les méthodes trust, password et ident ne doivent pas être utilisées pour les connexions à distance. La méthode md5 était autrefois la plus populaire et peut être utilisée dans des sessions chiffrées et non chiffrées. Cependant, elle est vulnérable aux attaques par relecture de paquets. Il est recommandé d\'utiliser scram-sha-256 à la place de md5. L\'utilisation des méthodes gss, sspi, pam, ldap, radius et cert dépend de la disponibilité de processus/services d\'authentification externes et n\'est donc pas couverte ici.',
		},
		'5.3' => {
			'title' => 'Vérifier que la complexité du mot de passe est configurée',
			'description' => 'Une gestion solide des mots de passe pour vos comptes PostgreSQL authentifiés localement vous protégera contre les techniques de force brute des attaquants. Ceci est particulièrement important si l\'authentification externe n\'est pas possible à mettre en œuvre en raison des exigences ou des restrictions de l\'application.',
		},
		'5.4' => {
			'title' => 'Vérifier que le délai d\'expiration et le délai d\'authentification sont bien configurés',
			'description' => 'Le délai d\'expiration de l\'authentification est le temps maximum autorisé pour terminer l\'authentification du client. Si un client potentiel n\'a pas terminé le protocole d\'authentification dans ce délai, le serveur ferme la connexion. Cela empêche les clients bloqués d\'occuper une connexion indéfiniment. Le délai d\'authentification entraîne une brève pause du serveur avant de signaler un échec d\'authentification, ce qui rend plus difficiles les attaques par force brute sur les mots de passe des bases de données. (*)',
		},
		'5.5' => {
			'title' => 'Vérifier que SSL est utilisé pour la connexion client',
			'description' => 'Toutes les connexions client distantes doivent être cryptées et les connexions non cryptées doivent être rejetées pour ne pas permettre le reniflage de données sur le réseau. (*)',
		},
		'5.6' => {
			'title' => 'Vérifier que les plages d\'adresses IP autorisées ne sont pas trop grandes',
			'description' => 'Autoriser une trop grande plage d\'adresses IP à se connecter au cluster PostgreSQL multiplie inutilement les risques. (*)',
		},
		'5.7' => {
			'title' => 'Vérifier que la base de données et les utilisateurs spécifiques sont utilisés',
			'description' => 'Le mot clé "all" dans la partie base de données et utilisateur des règles de pg_hba.conf peut permettre à n\'importe quel utilisateur de se connecter à n\'importe quelle base de données, il est recommandé de restreindre la connexion à un utilisateur et une base de données spécifiques. (*)',
		},
		'5.8' => {
			'title' => 'Vérifier que les superutilisateurs ne sont pas autorisés à se connecter à distance',
			'description' => 'Autoriser un superutilisateur PostgreSQL à se connecter à une base de données à partir d\'un hôte distant est dangereux, le mieux est d\'autoriser uniquement le(s) superutilisateur(s) à se connecter localement avec une authentification par un homologue. Si certains privilèges avancés sont requis, le mieux est d\'utiliser les rôles prédéfinis de PostgreSQL. (*)',
		},
		'5.9' => {
			'title' => 'Vérifier que \'password_encryption\' est positionné correctement.',
			'description' => 'PostgreSQL permet de définir l\'encryption utilisée pour le stockage des mots de passe, par défaut il est maintenant à \'scram-sha-256\' mais il pourrait être positionné à \'md5\' ce qui n\'est pas sécurisé. (*)',
		},
#-------------------------------
		'6' => {
			'title' => 'Paramètres PostgreSQL',
		},
		'6.1' => {
			'title' => 'Comprendre les vecteurs d\'attaque et les paramètres d\'exécution',
		},
		'6.2' => {
			'title' => 'Vérifier que les paramètres d\'exécution du \'backend\' sont correctement configurés',
			'description' => 'Un déni de service est possible en refusant l\'utilisation des index et en ralentissant l\'accès client à un niveau déraisonnable. Un comportement non autorisé peut être introduit en introduisant des bibliothèques malveillantes qui peuvent ensuite être appelées dans une session de base de données. La journalisation peut être modifiée et obscurcie, ce qui empêche l\'analyse des causes profondes. Toutes les modifications apportées à ce niveau affecteront le comportement global du serveur. Ces modifications ne peuvent être affectées que par un redémarrage du serveur après modification des paramètres dans les fichiers de configuration.',
		},
		'6.3' => {
			'title' => 'Vérifier que les paramètres d\'exécution de \'Postmaster\' sont correctement configurés',
			'description' => 'Le processus postmaster est le processus de supervision qui attribue un processus backend à une connexion client entrante. Le postmaster gère les paramètres d\'exécution clés qui sont soit partagés par toutes les connexions backend, soit nécessaires au processus postmaster lui-même pour s\'exécuter. Les paramètres suivants ne peuvent être définis au démarrage du serveur que par le propriétaire du processus et du cluster du serveur PostgreSQL, généralement le compte utilisateur UNIX postgres. Par conséquent, tous les exploits nécessitent la compromission réussie soit de ce compte UNIX, soit du compte superutilisateur Postgres lui-même.',
			'manuel' => 1,
		},
		'6.4' => {
			'title' => 'Vérifier que les paramètres d\'exécution de \'SIGHUP\' sont correctement configurés',
			'description' => 'Afin de définir le comportement du serveur et d\'optimiser ses performances, le superutilisateur du serveur a le privilège de définir ces paramètres qui se trouvent dans les fichiers de configuration postgresql.conf et pg_hba.conf. Alternativement, les paramètres trouvés dans postgresql.conf peuvent également être modifiés à l\'aide d\'une session de connexion au serveur et en exécutant la commande SQL ALTER SYSTEM qui écrit ses modifications dans le fichier de configuration postgresql.auto.conf. Toutes les modifications apportées à ce niveau affecteront le comportement global du serveur. Ces modifications peuvent être effectuées en éditant les fichiers de configuration de PostgreSQL et soit en exécutant un serveur SIGHUP à partir de la ligne de commande, soit, en tant que superutilisateur postgres, en exécutant la commande SQL select pg_reload_conf(). Un déni de service est possible en raison de la surallocation de ressources limitées, telles que la RAM. Les données peuvent être corrompues en permettant le chargement de pages endommagées ou en modifiant les paramètres pour réinterpréter les valeurs de manière inattendue, par exemple en modifiant le fuseau horaire. Les messages client peuvent être modifiés de manière à interférer avec la logique de l\'application. La journalisation peut être modifiée et obscurcie, empêchant ainsi l\'analyse des causes profondes.',
			'manuel' => 1,
		},
		'6.5' => {
			'title' => 'Vérifier que les paramètres d\'exécution du \'Superuser\' sont correctement configurés',
			'description' => 'Afin d\'améliorer et d\'optimiser les performances du serveur, le superutilisateur du serveur a le privilège de définir ces paramètres qui se trouvent dans le fichier de configuration postgresql.conf. Alternativement, ils peuvent être modifiés lors d\'une session de connexion PostgreSQL via la commande SQL ALTER SYSTEM qui écrit ses modifications dans le fichier de configuration postgresql.auto.conf. Toutes les modifications apportées à ce niveau affecteront le comportement global du serveur. Ces modifications ne peuvent être affectées que par un redémarrage du serveur après modification des paramètres dans les fichiers de configuration. Un déni de service est possible en raison de la surallocation de ressources limitées, telles que la RAM. Les données peuvent être corrompues en permettant le chargement de pages endommagées ou en modifiant les paramètres pour réinterpréter les valeurs de manière inattendue, par exemple en modifiant le fuseau horaire. Les messages client peuvent être modifiés de manière à interférer avec la logique de l\'application. La journalisation peut être modifiée et obscurcie, empêchant ainsi l\'analyse des causes profondes.',
			'manuel' => 1,
		},
		'6.6' => {
			'title' => 'Vérifier que les paramètres d\'exécution \'Utilisateur\' sont correctement configurés',
			'description' => 'Ces paramètres d\'exécution PostgreSQL sont gérés au niveau du compte utilisateur (ROLE). Afin d\'améliorer les performances et d\'optimiser les fonctionnalités, un ROLE a le privilège de définir de nombreux paramètres dans un attribut de transaction, de session ou d\'entité. N’importe quel RÔLE peut modifier n’importe lequel de ces paramètres. Un déni de service est possible en raison de la surallocation de ressources limitées, telles que la RAM. La modification des paramètres VACUUM peut forcer l\'arrêt du serveur, ce qui est une procédure standard empêchant la corruption des données due au bouclage de l\'ID de transaction. Les données peuvent être corrompues en modifiant les paramètres pour réinterpréter les valeurs de manière inattendue, par exemple en modifiant le fuseau horaire. La journalisation peut être modifiée et masquée pour empêcher l\'analyse des causes profondes.',
			'manuel' => 1,
		},
		'6.7' => {
			'title' => 'Vérifier que la cryptographie FIPS 140-2 OpenSSL est utilisée',
			'description' => 'Installer, configurer et utiliser OpenSSL sur une plate-forme disposant d\'une installation FIPS 140-2 d\'OpenSSL certifiée NIST. Cela donne aux instances PostgreSQL la possibilité de générer et de valider des hachages cryptographiques pour protéger les informations non classifiées nécessitant une confidentialité et une protection cryptographique, conformément aux exigences du propriétaire des données.',
		},
		'6.8' => {
			'title' => 'Vérifier que TLS est activé et configuré correctement',
			'description' => 'Si TLS n\'est pas activé et configuré correctement, cela augmente le risque de compromission des données lors du transit. Un certificat auto-signé peut être utilisé pour les tests, mais un certificat signé par une autorité de certification (CA) (soit l\'une des autorités de certification globales, soit une autorité locale) doit être utilisé en production afin que les clients puissent vérifier l\'identité du serveur. . Si tous les clients de base de données sont locaux dans l\'organisation, il est recommandé d\'utiliser une autorité de certification locale. Pour finalement activer et appliquer l\'authentification TLS pour le serveur, les enregistrements "hostssl" appropriés doivent être ajoutés au fichier pg_hba.conf.',
		},
		'6.9' => {
			'title' => 'Vérifier qu\'une extension cryptographique est installée',
			'description' => 'Les instances PostgreSQL traitant des données qui nécessitent des protections "données au repos" doivent utiliser des mécanismes cryptographiques pour empêcher la divulgation et la modification non autorisées des informations au repos. Ces mécanismes cryptographiques peuvent être natifs de PostgreSQL ou implémentés via un logiciel supplémentaire ou des paramètres de système d\'exploitation/système de fichiers, selon la situation.',
		},
		'6.10' => {
			'title' => 'Vérifier qu\'une extension d\'anonymisation de données installée',
			'description' => 'Pour masquer ou remplacer les informations permettant l\'identification des personnes ou empêcher l\'exposition de données sensibles, une extension d\'anonymisation des données devrait être installée sur l\'instance PostgreSQL. Verification que les extensions pg_anonymize ou anon sont définies dans \'session_preload_libraries\' (*).',
		},
		'7' => {
			'title' => 'Réplication',
		},
		'7.1' => {
			'title' => 'Vérifier qu\'un utilisateur réservé à la réplication est créé et utilisé pour la réplication en continu',
			'description' => 'Comme il n\'est pas nécessaire d\'être un superutilisateur pour initier une connexion de réplication, il convient de créer un compte spécifiquement pour la réplication. Cela permet de "verrouiller" davantage les utilisations du compte superutilisateur et suit le principe général d\'utiliser le moins de privilèges nécessaires.',
		},
		'7.2' => {
			'title' => 'Verifier que la journalisation des commandes de réplication est configurée',
			'description' => 'Une connexion de réplication réussie permet de décharger une copie complète des données stockées dans le cluster de données vers un autre hôte, potentiellement non sécurisé. En tant que tel, il est conseillé de consigner toutes les commandes de réplication exécutées dans votre cluster de bases de données pour garantir que les données ne sont pas déchargées vers un emplacement inattendu/indésirable.',
		},
		'7.3' => {
			'title' => 'Verifier que les sauvegardes de base sont configurées et fonctionnelles',
			'description' => 'Une \'sauvegarde de base\' est une copie du cluster de données de l\'hôte PRIMAIRE (PGDATA) et est utilisée pour créer des hôtes STANDBY et pour les mécanismes de récupération ponctuelle (PITR). Les sauvegardes de base doivent être copiées sur les réseaux de manière sécurisée à l\'aide d\'un mécanisme de transport crypté. La CLI PostgreSQL pg_basebackup peut être utilisée, cependant, le cryptage TLS doit être activé sur le serveur conformément à la section 6.8 de ce benchmark.',
		},
		'7.4' => {
			'title' => 'Verifier que l\'archivage WAL est configuré et fonctionnel',
			'description' => 'L\'archivage des journaux avec écriture anticipée (WAL), ou envoi des journaux, est le processus d\'envoi de fichiers journaux de transactions depuis l\'hôte PRIMAIRE vers un ou plusieurs hôtes DE VEILLE ou pour les archiver sur un périphérique de stockage distant pour une utilisation ultérieure. par exemple PITR. Il existe plusieurs utilitaires capables de copier des WAL, notamment, mais sans s\'y limiter, cp, scp, sftp et rynsc. Fondamentalement, le serveur suit un ensemble de paramètres d\'exécution qui définissent quand le WAL doit être copié à l\'aide de l\'un des utilitaires susmentionnés.',
		},
		'7.5' => {
			'title' => 'Vérifier que les paramètres de réplication en streaming sont correctement configurés',
			'description' => 'La réplication en streaming à partir d\'un hôte PRIMAIRE transmet des DDL, DML, des mots de passe et d\'autres activités et données potentiellement sensibles. Ces connexions doivent être protégées par Secure Sockets Layer (SSL). Vérifiez en STANDBY que Primary_conninfo contient \'sslmode=require sslcompression=1\'',
		},
		'8' => {
			'title' => 'Considérations spéciales sur la configuration',
			'description' => 'Les recommandations proposées ici tentent de répondre à certains des cas d\'utilisation les moins courants qui peuvent justifier des conseils/considérations supplémentaires en matière de configuration.',
		},
		'8.1' => {
			'title' => 'Vérifier que les emplacements des sous-répertoires PostgreSQL se trouvent en dehors du cluster de données',
			'description' => 'Ce rapport fait partie du chapitre "1.3 Garantir l\'initialisation réussie du cluster de données" .',
		},
		'8.2' => {
			'title' => 'Vérifier que l\'outil de sauvegarde et de restauration, \'pgBackRest\', est installé et configuré',
			'description' => 'La fonction de sauvegarde native de PostgreSQL pg_dump fournit des opérations de sauvegarde logiques adéquates mais ne fournit pas de récupération ponctuelle (PITR). La fonction PostgreSQL pg_basebackup effectue une sauvegarde physique des fichiers de base de données et fournit PITR, mais elle est limitée par un seul thread. Ces deux méthodologies sont standard dans l\'écosystème PostgreSQL et adaptées aux besoins particuliers de sauvegarde/récupération. pgBackRest offre une autre option avec des fonctionnalités et une flexibilité beaucoup plus robustes.',
		},
		'8.3' => {
			'title' => 'Verifier que les divers paramètres de configuration sont corrects',
			'description' => 'Cette recommandation couvre les fichiers spéciaux non réguliers et les bibliothèques dynamiques. PostgreSQL autorise les connexions locales via le SOCKET DE DOMAINE UNIX et, pour la plupart, toute personne disposant d\'un compte de connexion Unix légitime peut tenter cette tentative. Il est possible de limiter les tentatives de connexion à PostgreSQL en déplaçant le SOCKET DE DOMAINE UNIX vers un sous-répertoire avec des autorisations restreintes. La création et la mise en œuvre de bibliothèques dynamiques définies par l\'utilisateur constituent une capacité extraordinairement puissante. Entre les mains d\'un administrateur de base de données/programmeur expérimenté, il peut améliorer considérablement la puissance et la flexibilité du SGBDR ; mais un comportement nouveau et inattendu peut également être attribué au SGBDR, créant ainsi un environnement très dangereux dans lequel il faudrait autrement faire confiance.',
			'manuel' => 1,
		},
	},
#------------------------------------------------------------------------------------------------------
	'zh_CN' => {
#------------------------------------------------------------------------------------------------------
		'1' => {
			'title' => '安装和补丁',
		},
		'1.1' => {
			'title' => '确保软件包来自授权存储库',
			'description' => '识别并检查配置的存储库，以确保它们都是有效且经过授权的软件包来源。',
		},
		'1.1.1' => {
			'title' => '已安装 PostgreSQL 软件包。',
			'description' => '检查已安装的软件包，以确保它们都是有效且经过授权的软件包。',
			'manual' => 1,
		},
		'1.1.2' => {
			'title' => '确保软件包来自 PGDG',
			'description' => '通常不推荐使用 PostgreSQL 社区不支持的 PostgreSQL 软件包。',
		},
		'1.2' => {
			'title' => '确保 systemd 服务文件已启用',
			'description' => '检查 PostgreSQL systemd 服务是否已启用。启用 systemd PostgreSQL 服务可确保数据库服务在系统启动和重启时处于活动状态。如果安装了 Patroni，则不会进行此检查，在这种情况下，PostgreSQL 的启动由 Patroni 处理。 (HexaCLuster)',
		},
		'1.3' => {
			'title' => '确保数据集群初始化成功',
			'description' => 'PostgreSQL 强制执行数据集群的所有权和权限，使得其他 UNIX 用户帐户无法访问数据集群，并且数据集群不能由 root 拥有。',
		},
		'1.3.1' => {
			'title' => '检查 PGDATA 的初始化',
			'description' => '在启动 PostgreSQL 之前可能已经运行了命令 initdb，请验证是否是这种情况。',
		},
		'1.3.2' => {
			'title' => '检查 PGDATA 中的版本',
			'description' => 'PostgreSQL 在基目录中维护一个名为 PG_VERSION 的文件，请验证。',
		},
		'1.3.3' => {
			'title' => '确保数据集群已启用校验和',
			'description' => '当未启用校验和时，PostgreSQL 无法检测到静默数据损坏。请验证它们是否已启用。(*)',
		},
		'1.3.4' => {
			'title' => '确保 WAL 和临时文件与 PGDATA 不在同一分区',
			'description' => 'PostgreSQL 集群被组织为在子目录中执行特定任务。出于性能、可靠性和安全性的目的，其中一些子目录应重新定位到数据集群之外。(*)',
		},
		'1.3.5' => {
			'title' => '确保 PGDATA 分区已加密',
			'description' => 'PostgreSQL 存储加密可以在文件系统级别或块级别执行，例如使用 LUKS。如果驱动器或整个计算机被盗，此机制可防止从驱动器读取未加密的数据。这无法在文件系统挂载时防止攻击，因为挂载时，操作系统会提供未加密的数据视图。 (*)',
			'manual' => 1,
		},
		'1.4' => {
			'title' => '确保 PostgreSQL 版本是最新的',
			'descritption' => 'PostgreSQL 小升级仅包含错误和安全修复。小升级没有新功能、新错误，也没有兼容性问题，它们始终完全二进制兼容。您应该始终在小版本发布后立即安装它们。对于小版本，社区认为不升级比升级风险更大。',
		},
		'1.5' => {
			'title' => '确保删除未使用的 PostgreSQL 扩展',
			'descritption' => 'PostgreSQL 扩展是在数据库中创建的，有些可能不再使用。在数据库中继续安装未使用的扩展是有风险的。',
			'manual' => 1,
		},
		'1.6' => {
			'title' => '确保表空间位置不在 PGDATA 内',
			'descritption' => '在数据目录中创建表空间是无用的，出于性能原因和磁盘空间使用 (*) 不建议这样做。',
		},
#---------------------------
		'2' => {
			'title' => '目录和文件权限',
		},
		'2.1' => {
			'title' => '确保文件权限掩码正确',
			'description' => 'postgres 系统用户应该对文件创建具有限制性的 umask，以便其他 UNIX 用户无法查看任何内容。',
		},
		'2.2' => {
		'title' => '检查 PGDATA 的权限',
		'description' => '数据集群的 Unix 权限必须为 0700 (*)。',
		},
		'2.3' => {
			'title' => '列出 PGDATA 的内容以检查不需要的文件和符号链接',
			'description' => '除自定义配置文件外，PGDATA 的内容必须由 PostgreSQL 本身生成。(*)。',
			'manual' => 1,
		},
		'2.4' => {
			'title' => '检查 pg_hba.conf 的权限',
			'description' => 'pg_hba.conf 的 UNIX 权限必须为 0640 或 0600，尤其是当它存储在 PGDATA 之外时 (*)。',
		},
		'2.5' => {
			'title' => '检查 Unix Socket 上的权限',
			'description' => '默认权限为 0777，意味着任何人都可以连接。合理的替代方案是 0770（仅限用户和组，另请参阅 unix_socket_group）和 0700（仅限用户）。(*).',
		},
#---------------------------
		'3' => {
			'title' => '日志记录和审计',
		},
		'3.1' => {
			'title' => 'PostgreSQL 日志记录',
			'description' => '本节提供有关 PostgreSQL 日志记录行为在安全和审计方面的指导。',
		},
		'3.1.1' => {
			'title' => '日志记录原理',
			'description' => '拥有审计跟踪是任何关系数据库系统的重要功能。您需要足够详细的信息来描述感兴趣的事件何时开始和停止、事件是什么/是什么、事件的原因以及事件对系统做了什么/正在做什么。理想情况下，记录的信息采用一种允许进一步分析的格式，从而为我们提供新的视角和见解。',
		},
		'3.1.2' => {
			'title' => '确保正确设置了日志目标',
			'description' => '如果未设置 log_destination，则核心 PostgreSQL 进程生成的任何日志消息都将丢失。',
		},
		'3.1.3' => {
			'title' => '确保启用了日志收集器',
			'description' => '日志收集器方法通常比记录到 syslog 更有用，因为某些类型的消息可能不会出现在 syslog 输出中。一个常见的例子是动态链接器故障消息；另一个可能是由脚本（例如 archive_command）生成的错误消息。',
		},
		'3.1.4' => {
			'title' => '确保日志文件目标目录设置正确',
			'description' => '如果未设置 log_directory，它将被解释为绝对路径 \'/\'，并且 PostgreSQL 将尝试在那里写入其日志',
		},
		'3.1.5' => {
			'title' => '确保日志文件的文件名模式设置正确',
			'description' => '如果未设置 log_filename，则 log_directory 的值将附加到空字符串，并且 PostgreSQL 将无法启动，因为它将尝试写入目录而不是文件。',
			'manual' => 1,
		},
		'3.1.6' => {
			'title' => '确保日志文件权限设置正确',
			'description' => '日志文件通常包含敏感数据。允许不必要的日志文件访问可能会无意中将敏感数据暴露给未经授权的人员。',
		},
		'3.1.7' => {
			'title' => '确保启用 \'log_truncate_on_rotation\'',
			'description' => '如果禁用此设置，则如果 log_filename 配置为生成静态或重复名称，则会将预先存在的日志文件附加到其中。',
		},
		'3.1.8' => {
			'title' => '确保正确设置了最大日志文件生存期',
			'description' => '当前最佳实践建议至少每天轮换一次日志，但您组织的日志记录策略应决定您的轮换时间表。',
			'manual' => 1,
		},
		'3.1.9' => {
			'title' => '确保正确设置了最大日志文件大小',
			'description' => '如果将其设置为零，则禁用由大小触发的新日志文件创建。这将阻止文件过大时自动轮换日志文件，这可能会增加日志数据的丢失风险（除非配置了基于年龄的轮换）。',
			'manual' => 1,
		},
		'3.1.10' => {
			'title' => '确保选择了正确的 syslog 工具',
			'description' => '如果没有设置为适当的工具，PostgreSQL 日志消息可能会与其他应用程序日志消息混合，路由错误或可能被丢弃（取决于您的 syslog 配置）。',
			'manual' => 1,
		},
		'3.1.11' => {
			'title' => '确保 syslog 消息不被抑制',
			'description' => '如果禁用，发送到 Syslog 的消息可能会被抑制并且不会被记录。虽然会发出一条消息，表明某条消息被重复和抑制，但与这些被抑制的消息相关的时间戳会丢失，这可能会损害事件时间线的重建。',
		},
		'3.1.12' => {
			'title' => '确保系统日志消息不会因大小而丢失',
			'description' => '根据所使用的 Syslog 服务器，超过 1024 字节的日志消息可能会丢失，或者可能导致 Syslog 服务器进程中止。',
		},
		'3.1.13' => {
			'title' => '确保 PostgreSQL 系统日志消息的程序名称正确',
			'description' => '如果设置不正确，可能很难或无法区分 PostgreSQL 消息和 Syslog 日志中的其他消息。',
			'manual' => 1,
		},
		'3.1.14' => {
			'title' => '确保将正确的消息写入服务器日志',
			'description' => '如果未将其设置为正确的值，则可能会将过多或过少的消息写入服务器日志。',
		},
		'3.1.15' => {
			'title' => '确保记录正确的产生错误的 SQL 语句',
			'description' => '如果未将其设置为正确的值，则可能会将过多或过少的错误 SQL 语句写入服务器日志。',
		},
		'3.1.16' => {
			'title' => '确保 \'debug_print_parse\' 已禁用',
			'description' => '启用任何 DEBUG 打印变量可能会导致记录敏感信息，否则这些信息将被忽略根据其他日志设置的配置。',
		},
		'3.1.17' => {
			'title' => '确保 \'debug_print_rewritten\' 已禁用',
			'description' => '启用任何 DEBUG 打印变量可能会导致记录敏感信息，否则这些信息会根据其他日志设置的配置被忽略。',
		},
		'3.1.18' => {
			'title' => '确保 \'debug_print_plan\' 已禁用',
			'description' => '启用任何 DEBUG 打印变量可能会导致记录敏感信息，否则这些信息会根据其他日志设置的配置被忽略。',
		},
		'3.1.19' => {
			'title' => '确保 \'debug_pretty_print\' 已启用',
			'description' => '如果禁用此设置，则而是使用“紧凑”格式，这大大降低了 DEBUG 语句日志消息的可读性。',
		},
		'3.1.20' => {
			'title' => '确保 \'log_connections\' 已启用',
			'description' => 'PostgreSQL 不会在内部保留尝试连接到数据库的记录以供日后审核。只有通过启用这些尝试的日志记录，才能确定是否有意外尝试。',
		},
		'3.1.21' => {
			'title' => '确保 \'log_disconnections\' 已启用',
			'description' => 'PostgreSQL 不会在内部保留连接的开始或结束以供日后审查。只有启用这些日志记录功能，才能检查连接是否失败、持续时间过长或其他异常情况。',
		},
		'3.1.22' => {
			'title' => '确保正确设置 \'log_error_verbosity\'',
			'description' => '如果未将其设置为正确值，则可能会记录过多或过少的详细信息。',
		},
		'3.1.23' => {
			'title' => '确保正确设置 \'log_hostname\'',
			'description' => '根据您的主机名解析设置，启用此设置可能会造成不可忽略的性能损失。此外，在查看日志时，记录的 IP 地址可以解析为其 DNS 名称（除非动态主机名被用作 DHCP 设置的一部分）。',
		},
		'3.1.24' => {
			'title' => '确保 \'log_line_prefix\' 设置正确',
			'description' => '正确设置 log_line_prefix 允许向每个日志条目添加其他信息（例如用户或数据库）。上述信息可能在审计或安全审查中有用。前缀至少应包含 \'%m [%p]: db=%d,user=%u,app=%a,client=%h \'（用于记录到 stderr），对于 syslog 日志记录，前缀应包含 \'user=%u,db=%d,app=%a,client=%h \'。',
		},
		'3.1.25' => {
			'title' => '确保 \'log_statement\' 设置正确',
			'description' => '将 log_statement 设置为符合组织的安全和日志记录策略，有助于以后审计和查看数据库活动。',
		},
		'3.1.26' => {
			'title' => '确保 \'log_timezone\' 设置正确',
			'description' => '应根据组织的日志记录策略为适当的时区配置日志条目时间戳，以确保没有记录事件发生时间的混淆。请注意，此设置仅影响日志中存在的时间戳。',
		},
		'3.1.27' => {
			'title' => '确保 log_directory 位于 PGDATA 之外',
			'description' => '出于性能原因和磁盘空间使用，最佳做法是不要将 PostgreSQL 日志写入 PGDATA。(*)',
		},
		'3.2' => {
			'title' => '确保已启用 PostgreSQL 审计扩展 (pgAudit)',
			'description' => 'PostgreSQL 审计扩展 (pgAudit) 通过标准 PostgreSQL 日志记录工具提供详细的会话和/或对象审计日志记录。 pgAudit 的目标是为 PostgreSQL 用户提供生成审计日志的能力，而这些审计日志通常是政府、金融或 ISO 认证所必需的。',
		},
#---------------------------
		'4' => {
			'title' => '用户访问和授权',
			'description' => '这些授权必须通过设置用户能力限制来阻止未经授权的使用和/或破坏重要数据和服务。',
		},
		'4.1' => {
			'title' => '确保 sudo 配置正确',
			'description' => '如果没有 sudo，就没有能力严格控制对超级用户帐户的访问，也无法安全、权威地审计其使用情况。',
			'manual' => 1,
		},
		'4.2' => {
			'title' => '确保撤销过多的管理权限',
			'description' => '通过不将全局管理命令限制为仅限超级用户，被授予过多权限的普通用户可能会执行管理命令，从而导致意外和不良结果。',
		},
		'4.3' => {
			'title' => '确保撤销过多的函数权限',
			'description' => '可以使用 SECURITY DEFINER 选项创建 PostgreSQL 中的函数。当用户执行 SECURITY DEFINER 函数时，该函数将以权限运行s 是创建它的用户的权限，而不是运行它的用户的权限。每个数据库的 SECURITY DEFINER 选项未与扩展关联的函数列表。',
			'manual' => 1,
		},
		'4.4' => {
			'title' => '确保撤销过多的 DML 权限',
			'description' => '过多的 DML 授权可能导致无特权用户在未经适当授权的情况下更改或删除信息。',
			'manual' => 1,
		},
		'4.5' => {
			'title' => '确保行级安全性 (RLS) 配置正确',
			'description' => '如果 RLS 策略和权限配置不正确，用户可能会在未授权的表上执行操作，例如插入、更新或删除行。列出启用了 RLS 的表。',
			'manual' => 1,
		},
		'4.6' => {
			'title' => '确保安装了 set_user 扩展',
			'description' => '即使减少和限制对超级用户角色的访问，仍然很难确定谁访问了超级用户角色以及使用该角色执行了哪些操作。因此，理想的做法是防止任何人以超级用户身份登录并强迫他们升级其角色。 set_user 扩展允许进行此设置。',
			'manual' => 1,
		},
		'4.7' => {
			'title' => '使用预定义角色',
			'description' => '遵循最小权限原则，明智地使用 PostgreSQL 预定义角色可以极大地限制对特权或超级用户的访问。',
			'manual' => 1,
		},
		'4.8' => {
			'title' => '确保公共模式受到保护',
			'description' => '必须将 PostgreSQL 默认公共模式上的权限限制给某些用户，必须删除对公共用户的授予或删除模式。',
		},
#---------------
		'5' => {
			'title' => '连接和登录',
			'description' => '通过设置访问规则，对客户端/用户连接到 PostgreSQL 数据库的限制阻止了对数据和服务的未经授权的访问。这些安全措施有助于确保无法通过暴力密码攻击、重放密码哈希或巧妙的社会工程漏洞轻易成功登录。',
		},
		'5.1' => {
			'title' => '确保通过“本地”UNIX 域套接字登录配置正确',
			'description' => '通过 SSH 进行远程主机登录可以说是远程访问和管理 PostgreSQL 服务器最安全的方式。一旦连接到 PostgreSQL 服务器，使用 psql 客户端通过 UNIX 域套接字，同时使用对等身份验证方法是本地数据库连接最安全的机制。',
		},
		'5.2' => {
			'title' => '确保通过“主机”TCP/IP 套接字登录配置正确',
			'description' => '对于使用 TCP/IP 套接字连接的主机，有大量的身份验证方法可用。方法 trust、password 和 ident 不用于远程登录。方法 md5 曾经最流行，可用于加密和非加密会话，但它容易受到数据包重放攻击。建议使用 scram-sha-256 代替 md5。gss、sspi、pam、ldap、radius 和 cert 方法的使用取决于外部身份验证流程/服务的可用性，因此本文不作介绍。',
		},
		'5.3' => {
			'title' => '确保已配置密码复杂性',
			'description' => '对本地身份验证的 PostgreSQL 帐户进行强密码管理将防止攻击者使用暴力破解技术。这一点很重要，尤其是在由于应用程序要求或限制而无法实施外部身份验证的情况下。',
		},
		'5.4' => {
			'title' => '确保身份验证超时和延迟配置正确',
			'description' => '身份验证超时是允许完成客户端身份验证的最长时间。如果潜在客户端在这么长的时间内未完成身份验证协议，服务器将关闭连接。这可以防止挂起的客户端无限期地占用连接。身份验证延迟会导致服务器在报告身份验证失败之前短暂暂停，从而使对数据库密码的暴力攻击更加困难。 (*)',
		},
		'5.5' => {
			'title' => '确保客户端连接使用 SSL',
			'description' => '所有远程客户端连接都应加密，未加密的连接应被拒绝，以不允许在网络上嗅探数据。 (*)',
		},
		'5.6' => {
			'title' => '确保授权的 IP 地址范围不太大',
			'description' => '允许太大范围的 IP 地址连接到 PostgreSQL 集群会不必要地增加风险。 (*)',
		},
		'5.7' => {
			'title' => '确保使用特定的数据库和用户',
			'description' => 'pg_hba.conf 规则的数据库和用户部分中的关键字“all”可以允许任何用户连接到任何数据库，建议将连接限制在规范范围内ific 用户和数据库。 (*)',
		},
		'5.8' => {
			'title' => '确保超级用户不得远程连接',
			'description' => '允许 PostgreSQL 超级用户从远程主机连接到数据库是危险的，最好只允许超级用户使用对等身份验证在本地连接。如果需要一些高级权限，最好使用 PostgreSQL 预定义角色。 (*)',
		},
		'5.9' => {
			'title' => '确保 \'password_encryption\' 已正确设置',
			'description' => 'PostgreSQL 允许设置密码加密，默认现在为 \'scram-sha-256\'，但可以设置为不安全的 \'md5\'。 (*)',
		},
#------------------------------
		'6' => {
			'title' => 'PostgreSQL 设置',
		},
		'6.1' => {
			'title' => '了解攻击媒介和运行时参数',
		},
		'6.2' => {
			'title' => '确保 \'backend\' 运行时参数配置正确',
			'description' => '通过拒绝使用索引并将客户端访问速度降低到不合理的水平，可以实现拒绝服务。通过引入恶意库，然后可以在数据库会话中调用这些库，可以引入未经批准的行为。日志记录可以被更改和混淆，从而抑制根本原因分析。在此级别所做的所有更改都将影响服务器的整体行为。只有在配置文件中更改参数后，服务器重启才会影响这些更改。',
		},
		'6.3' => {
			'title' => '确保 \'Postmaster\' 运行时参数配置正确',
			'description' => 'postmaster 进程是将后端进程分配给传入客户端连接的监督进程。postmaster 管理关键运行时参数，这些参数要么由所有后端连接共享，要么由 postmaster 进程本身运行所需。以下参数只能由 PostgreSQL 服务器进程和集群的所有者（通常是 UNIX 用户帐户 postgres）在服务器启动时设置。因此，所有漏洞都需要成功入侵该 UNIX 帐户或 postgres 超级用户帐户本身。',
			'manual' => 1,
		},
		'6.4' => {
			'title' => '确保 \'SIGHUP\' 运行时参数配置正确',
			'description' => '为了定义服务器行为并优化服务器性能，服务器的超级用户有权设置这些参数，这些参数位于配置文件 postgresql.conf 和 pg_hba.conf 中。或者，也可以使用服务器登录会话并执行 SQL 命令 ALTER SYSTEM 来更改 postgresql.conf 中的那些参数，该命令会将其更改写入配置文件 postgresql.auto.conf。在此级别所做的所有更改都将影响服务器的整体行为。这些更改可以通过编辑 PostgreSQL 配置文件并从命令行执行服务器 SIGHUP 或以超级用户 postgres 身份执行 SQL 命令 select pg_reload_conf() 来实现。过度分配有限的资源（如 RAM）可能会导致拒绝服务。允许加载损坏的页面或更改参数以意外方式重新解释值（例如更改时区）可能会损坏数据。客户端消息可能会被更改，从而干扰应用程序逻辑。日志可能会被更改和混淆，从而阻碍根本原因分析。',
			'manual' => 1,
		},
		'6.5' => {
			'title' => '确保“超级用户”运行时参数配置正确',
			'description' => '为了改进和优化服务器性能，服务器的超级用户有权设置这些参数，这些参数位于配置文件 postgresql.conf 中。或者，可以通过 SQL 命令 ALTER SYSTEM 在 PostgreSQL 登录会话中更改它们，该命令将其更改写入配置文件 postgresql.auto.conf。在此级别所做的所有更改都将影响服务器的整体行为。只有在配置文件中更改参数后，服务器重启才能影响这些更改。过度分配有限的资源（如 RAM）可能会导致拒绝服务。允许加载损坏的页面或更改参数以意外方式重新解释值（例如更改时区）可能会损坏数据。客户端消息可能会被更改，从而干扰应用程序逻辑。日志记录可能会被更改和混淆，从而阻碍根本原因分析。',
			'manual' => 1,
		},
		'6.6' => {
			'title' => '确保正确配置 \'User\' 运行时参数',
			'description' => '这些 PostgreSQL 运行时参数在用户帐户（ROLE）级别进行管理。为了提高性能和优化功能，ROLE 有权在事务、会话或实体属性中设置许多参数。任何 ROLE 都可以更改这些参数中的任何一个。过度分配有限资源可能会导致拒绝服务es，例如 RAM。更改 VACUUM 参数可以强制服务器关闭，这是防止事务 ID 回绕导致数据损坏的标准程序。更改参数以意外方式重新解释值可能会损坏数据，例如更改时区。日志记录可能会被更改和混淆以阻止根本原因分析。',
			'manual' => 1,
		},
		'6.7' => {
			'title' => '确保使用 FIPS 140-2 OpenSSL 加密',
			'description' => '在具有 NIST 认证的 FIPS 140-2 OpenSSL 安装的平台上安装、配置和使用 OpenSSL。这为 PostgreSQL 实例提供了生成和验证加密哈希的能力，以根据数据所有者的要求保护需要机密性和加密保护的未分类信息。',
		},
		'6.8' => {
			'title' => '确保已启用并正确配置 TLS',
			'description' => '如果未启用并正确配置 TLS，则会增加数据在传输过程中被泄露的风险。自签名证书可用于测试，但应在生产中使用由证书颁发机构 (CA)（全球 CA 之一或本地 CA）签名的证书，以便客户端可以验证服务器的身份。如果所有数据库客户端都是组织本地的，则建议使用本地 CA。要最终为服务器启用和强制执行 TLS 身份验证，必须将适当的“hostssl”记录添加到 pg_hba.conf 文件中。',
		},
		'6.9' => {
			'title' => '确保安装了加密扩展',
			'description' => '处理需要“静态数据”保护的数据的 PostgreSQL 实例必须采用加密机制来防止未经授权披露和修改静态信息。这些加密机制可能是 PostgreSQL 原生的，也可以通过其他软件或操作系统/文件系统设置实现，具体取决于具体情况。',
		},
		'6.10' => {
			'title' => '确保安装了数据匿名化扩展',
			'description' => '为了掩盖或替换可能允许识别人员的信息或防止泄露敏感数据，应在 PostgreSQL 集群上安装数据匿名化扩展。检查 \'session_preload_libraries\' (*) 中是否设置了扩展 pg_anonymize 或 anon。',
		},
		'7' => {
			'title' => '复制',
		},
		'7.1' => {
			'title' => '确保创建仅复制用户并将其用于流式复制',
			'description' => '由于无需成为超级用户即可启动复制连接，因此专门为复制创建帐户是适当的。这允许进一步“锁定”超级用户帐户的使用，并遵循使用最少必要权限的一般原则。',
		},
		'7.2' => {
			'title' => '确保配置了复制命令的日志记录',
			'description' => '成功的复制连接允许将存储在数据集群内的数据的完整副本卸载到另一个可能不安全的主机。因此，建议记录在数据库集群中执行的所有复制命令，以确保数据不会被卸载到意外/不需要的位置。',
		},
		'7.3' => {
			'title' => '确保基本备份已配置并可正常运行',
			'description' => '“基本备份”是主主机数据集群 (PGDATA) 的副本，用于创建备用主机和时间点恢复 (PITR) 机制。应使用加密传输机制以安全的方式跨网络复制基本备份。可以使用 PostgreSQL CLI pg_basebackup，但是，应根据本基准测试的第 6.8 节在服务器上启用 TLS 加密。',
		},
		'7.4' => {
			'title' => '确保 WAL 归档已配置并正常运行',
			'description' => '预写日志 (WAL) 归档或日志传送是将事务日志文件从主主机发送到一个或多个备用主机或归档到远程存储设备以供日后使用（例如 PITR）的过程。有几种可以复制 WAL 的实用程序，包括但不限于 cp、scp、sftp 和 rynsc。基本上，服务器遵循一组运行时参数，这些参数定义何时应使用上述实用程序之一复制 WAL。',
		},
		'7.5' => {
			'title' => '确保流复制参数配置正确',
			'description' => '来自 PRIMARY 主机的流复制传输 DDL、DML、密码和其他潜在敏感活动和数据。这些连接应使用安全套接字层 (SSL) 进行保护。在 STANDBY 上验证 primary_conninfo 是否包含 \'sslmode=require sslcompression=1\'',
		},
		'8' => {
			'title' => '特殊配置注意事项',
			'description' => '此处提出的建议试图解决一些不太常见的用例，这些用例可能需要额外的配置指导/考虑。',
		},
		'8.1' => {
			'title' => '确保 PostgreSQL 子目录位置位于数据集群之外',
			'description' => '本报告是<a href="#1.3">“1.3 确保数据集群成功初始化”</a>章的一部分。',
		},
		'8.2' => {
			'title' => '确保备份和恢复工具 \'pgBackRest\' 已安装并配置',
			'description' => '本机 PostgreSQL 备份工具 pg_dump 提供足够的逻辑备份操作，但不提供时间点恢复 (PITR)。PostgreSQL 工具 pg_basebackup 执行数据库文件的物理备份并提供 PITR，但它受到单线程的限制。这两种方法都是 PostgreSQL 生态系统中的标准，适用于特定的备份/恢复需求。 pgBackRest 提供了另一种具有更强大功能和灵活性的选项。',
		},
		'8.3' => {
			'title' => '确保其他配置设置正确',
			'description' => '此建议涵盖非常规、特殊文件和动态库。PostgreSQL 允许通过 UNIX DOMAIN SOCKET 进行本地登录，并且在大多数情况下，任何拥有合法 Unix 登录帐户的人都可以尝试。可以通过将 UNIX DOMAIN SOCKET 重新定位到具有受限权限的子目录来限制 PostgreSQL 登录尝试。创建和实施用户定义的动态库是一项非常强大的功能。在经验丰富的 DBA/程序员手中，它可以显著增强 RDBMS 的功能和灵活性；但新的和意外的行为也可能被分配给 RDBMS，从而导致原本应该信任的环境非常危险。',
			'manual' => 1,
		},
	},
);

1;

